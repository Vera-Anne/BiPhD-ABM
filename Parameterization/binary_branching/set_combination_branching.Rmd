---
title: "Making branches for each model"
author: "Vera Vinken"
date: "`r Sys.Date()`"
output: html_document
---
  
## Packages 

```{r packages, include=TRUE, message=FALSE, warning=FALSE}

```

## Background

## Dummy variables 
These are useful when coding/debugging 
```{r create some dummies, include=T, echo=F, message=F, eval=F}
start_min_th1<-0
start_max_th1<-4

start_min_th2<-0
start_max_th2<-4

start_min_th3<-0
start_max_th3<-4

branch_num<-4


start_min_v1_th1<-0
start_max_v1_th1<-0.4
start_min_v2_th1<-0
start_max_v2_th1<-4
```


## Functions for single -variable models 

```{r functions, include=TRUE, message=F, warning=F}

# Basic branching function 
    branch_func<-function(range_min, range_max, branch_num){
      # determine stepsize
      step_size<<-((range_max-range_min)/branch_num)
      
      # Set the value for the threshold for each branch
      th_b1<-range_min + (step_size/2)
      th_b2<-(th_b1+step_size)
      th_b3<-(th_b2+step_size)
      th_b4<-(th_b3+step_size)
      
      # concatenate output 
      output_branches<<-c(th_b1, th_b2, th_b3, th_b4, step_size)
      return(output_branches)
    }


# Build a tree 
    tree_func<-function(start_min, start_max, branch_num, depth){
      
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            tree_output_list<-list()
          
        # Run the function 
          out<-branch_func(range_min = start_min, range_max = start_max, branch_num = branch_num)
        # Add the output 
          tree_output_list[1]<-out[[1]]
          tree_output_list[2]<-out[[2]]
          tree_output_list[3]<-out[[3]]
          tree_output_list[4]<-out[[4]]
          
          names<-c(out[[1]], out[[2]], out[[3]], out[[4]])
          names(tree_output_list)<-names
          } else if (i==2){
        
        # if i = 2 or higher 
            
        # Set previous step stepsize
        step_size_prev_step<-step_size
        
        # Determine the new ranges for each of the 4 branches 
        for (j in 1:branch_num){
          
          # Calculate the new minimum 
          cur_min<-(tree_output_list[[j]][[1]]-(0.5*step_size_prev_step))
          cur_max<-(tree_output_list[[j]][[1]]+(0.5*step_size_prev_step))
          
          # run the function 
          out<-branch_func(range_min = cur_min, range_max = cur_max, branch_num = branch_num)
          
  # add it to the list 
          tree_output_list[[j]][1]<-list(out[1])
          tree_output_list[[j]][2]<-list(out[2])
          tree_output_list[[j]][3]<-list(out[3])
          tree_output_list[[j]][4]<-list(out[4])
          
          names<-c(out[[1]], out[[2]], out[[3]], out[[4]])
          names(tree_output_list[[j]])<-names

        } # end of 4 branches 
        
        
  }else if (i==3){
            # Set previous step stepsize
        step_size_prev_step<-step_size
        
        # Determine the new ranges for each of the 4 branches 
        for (k in 1:branch_num){
          
          for(l in 1:branch_num){
          
          # Calculate the new minimum 
          cur_min<-(tree_output_list[[k]][[l]]-(0.5*step_size_prev_step))
          cur_max<-(tree_output_list[[k]][[l]]+(0.5*step_size_prev_step))
          
          # run the function 
          out<-branch_func(range_min = cur_min, range_max = cur_max, branch_num = branch_num)
          
          # add it to the list 
          tree_output_list[[k]][[l]][1]<-list(out[1])
          tree_output_list[[k]][[l]][2]<-list(out[2])
          tree_output_list[[k]][[l]][3]<-list(out[3])
          tree_output_list[[k]][[l]][4]<-list(out[4])
          
                    
          names<-c(out[[1]], out[[2]], out[[3]], out[[4]])
          names(tree_output_list[[k]][[l]])<-names
          } # end of the for loop 'l' 
          
          
        } # end of 4 branches 
  } 
      }# end of the for loop 
      
      return(tree_output_list)
    } # en dof the funciton 
    
# Build a tree for the x.2 models (subset 1 - one variable)
    tree_func_x2<-function(start_min_th1, start_max_th1, start_min_th2, start_max_th2, branch_num){
      depth<-3
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_th1<-branch_func(range_min = start_min_th1, range_max = start_max_th1, branch_num = branch_num)
              out_th2<-branch_func(range_min= start_min_th2, range_max = start_max_th2, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_th1[5], out_th2[5]))
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_th1[1:4], out_th2[1:4])
              colnames(grid)<-c("th1", "th2")
            # Subset this for cases where th2 > th 1 
              grid<-grid%>%
                filter(th1<th2)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
          }else if(i==2){
            # So for level 2
              for (j in 1:nrow(tree_output_list[[i-1]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_th1<-(tree_output_list[[i-1]][[1]][[j]]-(0.5*stepsize_list[[i-1]][[1]]))
                  cur_min_th2<-(tree_output_list[[i-1]][[2]][[j]]-(0.5*stepsize_list[[i-1]][[2]]))
                  # calculate the new maximum 
                  cur_max_th1<-(tree_output_list[[i-1]][[1]][[j]]+(0.5*stepsize_list[[i-1]][[1]]))
                  cur_max_th2<-(tree_output_list[[i-1]][[2]][[j]]+(0.5*stepsize_list[[i-1]][[2]]))
            
                  # run the function 
                  out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                  out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list[[i]]<-as.data.frame(cbind(out_th1[5], out_th2[5]))
      
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_th1[1:4], out_th2[1:4])
                  colnames(grid)<-c("th1", "th2")
                  # Subset this for cases where th2 > th 1 
                  grid<-grid%>%
                    filter(th1<th2)
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  
              }
            # sort naming 
            names(level_list)<-c(
                                        (paste(tree_output_list[[1]][[1]][[1]], "&", tree_output_list[[1]][[2]][[1]])), 
                                        (paste(tree_output_list[[1]][[1]][[2]], "&", tree_output_list[[1]][[2]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[3]], "&", tree_output_list[[1]][[2]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[4]], "&", tree_output_list[[1]][[2]][[4]])),
                                        (paste(tree_output_list[[1]][[1]][[5]], "&", tree_output_list[[1]][[2]][[5]])),
                                        (paste(tree_output_list[[1]][[1]][[6]], "&", tree_output_list[[1]][[2]][[6]])))
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            
          }else if(i==3){
            # For level 3 
            # This can't be the same as 2, because the structure of teh list won't be the same 
            # For any additional levels this would probably be teh case. 
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[i-1]][[1]]))
                      cur_min_th2<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[i-1]][[2]]))
                      # calculate the new maximum 
                      cur_max_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[i-1]][[1]]))
                      cur_max_th2<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[i-1]][[2]]))
                
                      # run the function 
                      out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                      out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list[[i]]<-as.data.frame(cbind(out_th1[5], out_th2[5]))
      
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_th1[1:4], out_th2[1:4])
                      colnames(grid)<-c("th1", "th2")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                        filter(th1<th2)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                  }
                   # sort naming 
                    names(list_new_th)<-c(
                                        (paste(tree_output_list[[2]][[1]][[1]][[1]], "&", tree_output_list[[2]][[1]][[2]][[1]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[2]], "&", tree_output_list[[2]][[1]][[2]][[2]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[3]], "&", tree_output_list[[2]][[1]][[2]][[3]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[4]], "&", tree_output_list[[2]][[1]][[2]][[4]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[5]], "&", tree_output_list[[2]][[1]][[2]][[5]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[6]], "&", tree_output_list[[2]][[1]][[2]][[6]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[7]], "&", tree_output_list[[2]][[1]][[2]][[7]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[8]], "&", tree_output_list[[2]][[1]][[2]][[8]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[9]], "&", tree_output_list[[2]][[1]][[2]][[9]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[10]], "&", tree_output_list[[2]][[1]][[2]][[10]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[11]], "&", tree_output_list[[2]][[1]][[2]][[11]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[12]], "&", tree_output_list[[2]][[1]][[2]][[12]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[13]], "&", tree_output_list[[2]][[1]][[2]][[13]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[14]], "&", tree_output_list[[2]][[1]][[2]][[14]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[15]], "&", tree_output_list[[2]][[1]][[2]][[15]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[16]], "&", tree_output_list[[2]][[1]][[2]][[16]]))
                                        )
              
              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
            }
            # sort naming 
            names(level_list)<-c(
                                        (paste(tree_output_list[[1]][[1]][[1]], "&", tree_output_list[[1]][[2]][[1]])), 
                                        (paste(tree_output_list[[1]][[1]][[2]], "&", tree_output_list[[1]][[2]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[3]], "&", tree_output_list[[1]][[2]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[4]], "&", tree_output_list[[1]][[2]][[4]])),
                                        (paste(tree_output_list[[1]][[1]][[5]], "&", tree_output_list[[1]][[2]][[5]])),
                                        (paste(tree_output_list[[1]][[1]][[6]], "&", tree_output_list[[1]][[2]][[6]])))
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
          }
        
      } # end the for loop 
   names(tree_output_list)<-c("level1", "level2", "level3")
   return(tree_output_list)
} # End hte function 
        
    
# Build a tree for the x.2 models (subset 1 - one variable)
    tree_func_x3<-function(start_min_th1, start_max_th1, start_min_th2, start_max_th2, start_min_th3, start_max_th3, branch_num){
      depth<-3
      
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_th1<-branch_func(range_min = start_min_th1, range_max = start_max_th1, branch_num = branch_num)
              out_th2<-branch_func(range_min= start_min_th2, range_max = start_max_th2, branch_num = branch_num)
              out_th3<-branch_func(range_min= start_min_th3, range_max = start_max_th3, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_th1[branch_num+1], out_th2[branch_num+1], out_th3[branch_num+1]))
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_th1[1:branch_num], out_th2[1:branch_num], out_th3[1:branch_num])
              colnames(grid)<-c("th1", "th2", "th3")
            # Subset this for cases where th2 > th 1 
              grid<-grid%>%
                filter(th1<th2 & th2<th3)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
          }else if(i==2){
            # So for level 2
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_th1<-(tree_output_list[[i-1]][[1]][[j]]-(0.5*stepsize_list[[i-1]][[1]]))
                  cur_min_th2<-(tree_output_list[[i-1]][[2]][[j]]-(0.5*stepsize_list[[i-1]][[2]]))
                  cur_min_th3<-(tree_output_list[[i-1]][[3]][[j]]-(0.5*stepsize_list[[i-1]][[3]]))
                  # calculate the new maximum 
                  cur_max_th1<-(tree_output_list[[i-1]][[1]][[j]]+(0.5*stepsize_list[[i-1]][[1]]))
                  cur_max_th2<-(tree_output_list[[i-1]][[2]][[j]]+(0.5*stepsize_list[[i-1]][[2]]))
                  cur_max_th3<-(tree_output_list[[i-1]][[3]][[j]]+(0.5*stepsize_list[[i-1]][[3]]))
            
                  # run the function 
                  out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                  out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  out_th3<-branch_func(range_min = cur_min_th3, range_max = cur_max_th3, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list[[i]]<-as.data.frame(cbind(out_th1[branch_num+1], out_th2[branch_num+1], out_th3[branch_num+1]))
      
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_th1[1:branch_num], out_th2[1:branch_num], out_th3[1:branch_num])
                  colnames(grid)<-c("th1", "th2", "th3")
                  # Subset this for cases where th2 > th 1 
                  grid<-grid%>%
                    filter(th1<th2 & th2<th3)
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  
              }
            # sort naming 
            names(level_list)<-c(
                                        (paste(tree_output_list[[1]][[1]][[1]], "&", tree_output_list[[1]][[2]][[1]], "&" , tree_output_list[[1]][[3]][[1]])), 
                                        (paste(tree_output_list[[1]][[1]][[2]], "&", tree_output_list[[1]][[2]][[2]], "&" , tree_output_list[[1]][[3]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[3]], "&", tree_output_list[[1]][[2]][[3]], "&" , tree_output_list[[1]][[3]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[4]], "&", tree_output_list[[1]][[2]][[4]], "&" , tree_output_list[[1]][[3]][[4]])))
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            
          }else if(i==3){
            # For level 3 
            # This can't be the same as 2, because the structure of teh list won't be the same 
            # For any additional levels this would probably be teh case. 
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[i-1]][[1]]))
                      cur_min_th2<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[i-1]][[2]]))
                      cur_min_th3<-(tree_output_list[[2]][[j]][[3]][[k]]-(0.5*stepsize_list[[i-1]][[3]]))
                      # calculate the new maximum 
                      cur_max_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[i-1]][[1]]))
                      cur_max_th2<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[i-1]][[2]]))
                      cur_max_th3<-(tree_output_list[[2]][[j]][[3]][[k]]+(0.5*stepsize_list[[i-1]][[3]]))
                
                      # run the function 
                      out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                      out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                      out_th3<-branch_func(range_min = cur_min_th3, range_max = cur_max_th3, branch_num = branch_num)
                  
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list[[i]]<-as.data.frame(cbind(out_th1[branch_num+1], out_th2[branch_num+1], out_th3[branch_num+1]))
      
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_th1[1:branch_num], out_th2[1:branch_num], out_th3[1:branch_num])
                      colnames(grid)<-c("th1", "th2", "th3")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                        filter(th1<th2 & th2<th3)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                  }
                   # sort naming 
                    names(list_new_th)<-c(
                                        (paste(tree_output_list[[2]][[1]][[1]][[1]], "&", tree_output_list[[2]][[1]][[2]][[1]], "&", tree_output_list[[2]][[1]][[3]][[1]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[2]], "&", tree_output_list[[2]][[1]][[2]][[2]], "&", tree_output_list[[2]][[1]][[3]][[2]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[3]], "&", tree_output_list[[2]][[1]][[2]][[3]], "&", tree_output_list[[2]][[1]][[3]][[3]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[4]], "&", tree_output_list[[2]][[1]][[2]][[4]], "&", tree_output_list[[2]][[1]][[3]][[4]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[5]], "&", tree_output_list[[2]][[1]][[2]][[5]], "&", tree_output_list[[2]][[1]][[3]][[5]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[6]], "&", tree_output_list[[2]][[1]][[2]][[6]], "&", tree_output_list[[2]][[1]][[3]][[6]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[7]], "&", tree_output_list[[2]][[1]][[2]][[7]], "&", tree_output_list[[2]][[1]][[3]][[7]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[8]], "&", tree_output_list[[2]][[1]][[2]][[8]], "&", tree_output_list[[2]][[1]][[3]][[8]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[9]], "&", tree_output_list[[2]][[1]][[2]][[9]], "&", tree_output_list[[2]][[1]][[3]][[9]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[10]], "&", tree_output_list[[2]][[1]][[2]][[10]], "&", tree_output_list[[2]][[1]][[3]][[10]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[11]], "&", tree_output_list[[2]][[1]][[2]][[11]], "&", tree_output_list[[2]][[1]][[3]][[11]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[12]], "&", tree_output_list[[2]][[1]][[2]][[12]], "&", tree_output_list[[2]][[1]][[3]][[12]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[13]], "&", tree_output_list[[2]][[1]][[2]][[13]], "&", tree_output_list[[2]][[1]][[3]][[13]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[14]], "&", tree_output_list[[2]][[1]][[2]][[14]], "&", tree_output_list[[2]][[1]][[3]][[14]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[15]], "&", tree_output_list[[2]][[1]][[2]][[15]], "&", tree_output_list[[2]][[1]][[3]][[15]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[16]], "&", tree_output_list[[2]][[1]][[2]][[16]], "&", tree_output_list[[2]][[1]][[3]][[16]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[17]], "&", tree_output_list[[2]][[1]][[2]][[17]], "&", tree_output_list[[2]][[1]][[3]][[17]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[18]], "&", tree_output_list[[2]][[1]][[2]][[18]], "&", tree_output_list[[2]][[1]][[3]][[18]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[19]], "&", tree_output_list[[2]][[1]][[2]][[19]], "&", tree_output_list[[2]][[1]][[3]][[19]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[20]], "&", tree_output_list[[2]][[1]][[2]][[20]], "&", tree_output_list[[2]][[1]][[3]][[20]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[21]], "&", tree_output_list[[2]][[1]][[2]][[21]], "&", tree_output_list[[2]][[1]][[3]][[21]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[22]], "&", tree_output_list[[2]][[1]][[2]][[22]], "&", tree_output_list[[2]][[1]][[3]][[22]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[23]], "&", tree_output_list[[2]][[1]][[2]][[23]], "&", tree_output_list[[2]][[1]][[3]][[23]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[24]], "&", tree_output_list[[2]][[1]][[2]][[24]], "&", tree_output_list[[2]][[1]][[3]][[24]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[25]], "&", tree_output_list[[2]][[1]][[2]][[25]], "&", tree_output_list[[2]][[1]][[3]][[25]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[26]], "&", tree_output_list[[2]][[1]][[2]][[26]], "&", tree_output_list[[2]][[1]][[3]][[26]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[27]], "&", tree_output_list[[2]][[1]][[2]][[27]], "&", tree_output_list[[2]][[1]][[3]][[27]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[28]], "&", tree_output_list[[2]][[1]][[2]][[28]], "&", tree_output_list[[2]][[1]][[3]][[28]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[29]], "&", tree_output_list[[2]][[1]][[2]][[29]], "&", tree_output_list[[2]][[1]][[3]][[29]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[30]], "&", tree_output_list[[2]][[1]][[2]][[30]], "&", tree_output_list[[2]][[1]][[3]][[30]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[31]], "&", tree_output_list[[2]][[1]][[2]][[31]], "&", tree_output_list[[2]][[1]][[3]][[31]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[32]], "&", tree_output_list[[2]][[1]][[2]][[32]], "&", tree_output_list[[2]][[1]][[3]][[32]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[33]], "&", tree_output_list[[2]][[1]][[2]][[33]], "&", tree_output_list[[2]][[1]][[3]][[33]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[34]], "&", tree_output_list[[2]][[1]][[2]][[34]], "&", tree_output_list[[2]][[1]][[3]][[34]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[35]], "&", tree_output_list[[2]][[1]][[2]][[35]], "&", tree_output_list[[2]][[1]][[3]][[35]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[36]], "&", tree_output_list[[2]][[1]][[2]][[36]], "&", tree_output_list[[2]][[1]][[3]][[36]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[37]], "&", tree_output_list[[2]][[1]][[2]][[37]], "&", tree_output_list[[2]][[1]][[3]][[37]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[38]], "&", tree_output_list[[2]][[1]][[2]][[38]], "&", tree_output_list[[2]][[1]][[3]][[38]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[39]], "&", tree_output_list[[2]][[1]][[2]][[39]], "&", tree_output_list[[2]][[1]][[3]][[39]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[40]], "&", tree_output_list[[2]][[1]][[2]][[40]], "&", tree_output_list[[2]][[1]][[3]][[40]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[41]], "&", tree_output_list[[2]][[1]][[2]][[41]], "&", tree_output_list[[2]][[1]][[3]][[41]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[42]], "&", tree_output_list[[2]][[1]][[2]][[42]], "&", tree_output_list[[2]][[1]][[3]][[42]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[43]], "&", tree_output_list[[2]][[1]][[2]][[43]], "&", tree_output_list[[2]][[1]][[3]][[43]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[44]], "&", tree_output_list[[2]][[1]][[2]][[44]], "&", tree_output_list[[2]][[1]][[3]][[44]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[45]], "&", tree_output_list[[2]][[1]][[2]][[45]], "&", tree_output_list[[2]][[1]][[3]][[45]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[46]], "&", tree_output_list[[2]][[1]][[2]][[46]], "&", tree_output_list[[2]][[1]][[3]][[46]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[47]], "&", tree_output_list[[2]][[1]][[2]][[47]], "&", tree_output_list[[2]][[1]][[3]][[47]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[48]], "&", tree_output_list[[2]][[1]][[2]][[48]], "&", tree_output_list[[2]][[1]][[3]][[48]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[49]], "&", tree_output_list[[2]][[1]][[2]][[49]], "&", tree_output_list[[2]][[1]][[3]][[49]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[50]], "&", tree_output_list[[2]][[1]][[2]][[50]], "&", tree_output_list[[2]][[1]][[3]][[50]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[51]], "&", tree_output_list[[2]][[1]][[2]][[51]], "&", tree_output_list[[2]][[1]][[3]][[51]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[52]], "&", tree_output_list[[2]][[1]][[2]][[52]], "&", tree_output_list[[2]][[1]][[3]][[52]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[53]], "&", tree_output_list[[2]][[1]][[2]][[53]], "&", tree_output_list[[2]][[1]][[3]][[53]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[54]], "&", tree_output_list[[2]][[1]][[2]][[54]], "&", tree_output_list[[2]][[1]][[3]][[54]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[55]], "&", tree_output_list[[2]][[1]][[2]][[55]], "&", tree_output_list[[2]][[1]][[3]][[55]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[56]], "&", tree_output_list[[2]][[1]][[2]][[56]], "&", tree_output_list[[2]][[1]][[3]][[56]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[57]], "&", tree_output_list[[2]][[1]][[2]][[57]], "&", tree_output_list[[2]][[1]][[3]][[57]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[58]], "&", tree_output_list[[2]][[1]][[2]][[58]], "&", tree_output_list[[2]][[1]][[3]][[58]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[59]], "&", tree_output_list[[2]][[1]][[2]][[59]], "&", tree_output_list[[2]][[1]][[3]][[59]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[60]], "&", tree_output_list[[2]][[1]][[2]][[60]], "&", tree_output_list[[2]][[1]][[3]][[60]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[61]], "&", tree_output_list[[2]][[1]][[2]][[61]], "&", tree_output_list[[2]][[1]][[3]][[61]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[62]], "&", tree_output_list[[2]][[1]][[2]][[62]], "&", tree_output_list[[2]][[1]][[3]][[62]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[63]], "&", tree_output_list[[2]][[1]][[2]][[63]], "&", tree_output_list[[2]][[1]][[3]][[63]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[64]], "&", tree_output_list[[2]][[1]][[2]][[64]], "&", tree_output_list[[2]][[1]][[3]][[64]]))
                                        )
              
            # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
            }
            # sort naming 
            names(level_list)<-c(
                                        (paste(tree_output_list[[1]][[1]][[1]], "&", tree_output_list[[1]][[2]][[1]], "&" , tree_output_list[[1]][[3]][[1]])), 
                                        (paste(tree_output_list[[1]][[1]][[2]], "&", tree_output_list[[1]][[2]][[2]], "&" , tree_output_list[[1]][[3]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[3]], "&", tree_output_list[[1]][[2]][[3]], "&" , tree_output_list[[1]][[3]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[4]], "&", tree_output_list[[1]][[2]][[4]], "&" , tree_output_list[[1]][[3]][[4]])))
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
          }
        
      } # end the for loop 
   names(tree_output_list)<-c("level1", "level2", "level3")
   return(tree_output_list)
} # End hte function 
        
    
# Also load the function file dependencies in order to run the models
  # setwd("C:/Local_R/BiPhD-ABM/May23")
  # source('MOD_1_FuncSource.R')
  # source('ModelSource.R')
```

## Run the functions 
Run the tree-function for the FR 2.1 model, which will start at 0 and end at 4, for 4 branches and with a depth of 3 (the maximum possible)

```{r run branching, include=TRUE, message=F, warning=F}
outcome_21<-tree_func(start_min = 0, start_max = 4, branch_num = 4, depth = 3)
```

Now for the SC 1.1 model, which starts at 0.4 and ends at 4, 4 branches and depth 3. 
```{r run for SC 11 branching, include=T, message=F, warning=F}
outcome_11<-tree_func(start_min = 0, start_max=0.4, branch_num = 4, depth=3)

```

Now for the FLR 3.1 model, which starts at -0.6 and ends at 0.6, 4 branches and depth 3. 
```{r run for SC 11 branching, include=T, message=F, warning=F}
outcome_31<-tree_func(start_min = -0.6, start_max=0.6, branch_num = 4, depth=3)

```


## Combine multiple trhesholds for X.2 models 
Write a function 
```{r combine thresholds, include=T, message=F, warning=F}


```
Run the function 
```{r run the function , include=T, message=F, warning=F}
 
out_x2<-tree_func_x2(start_min_th1 = 0, start_max_th1 = 0.4, start_min_th2 = 0, start_max_th2 = 0.4, branch_num = 4) 
```

## Different approach: run the model directly

```{r work through combination tree 1.1, include=T, message=F, warning=F}
branch_4_optimization_x1<-function(model_type, range_min_start, range_max_start){
  
  ##### LEVEL 1 
      # Run the branch function 
      vals_l1<-branch_func(range_min = range_min_start, range_max = range_max_start, branch_num = 4)
      
      # Now run the model 
      for (i in 1:4){
        if (i==1){
          # Create empty list for results 
          level_1_results<<-list()
        }
        # Set current th 
        cur_th<-vals_l1[i]
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:25){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==11){
                env_func_1_1_par(days = 30, N= 1000, th_forage_sc = cur_th, daylight_h = 8, modelType = 11)
              }else if(model_type==21){
                env_func_2_1_par(days = 30, N= 1000, th_forage_fr = cur_th, daylight_h = 8, modelType = 21)
              }else if(model_type==31){
                env_func_3_1_par(days = 30, N= 1000, th_forage_flr = cur_th, daylight_h = 8, modelType = 31)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th)
          # add to list
          level_1_results[[i]]<<-mean_perf
          # mark that things are working
          print(paste("Done with level 1 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l1<-data.frame(matrix(unlist(level_1_results), nrow=4, byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th")
      colnames(halflife_out_l1)<-names
      
      # select highest outcome
      max_HL_l1<-max(halflife_out_l1$HL)
      best_l1<-halflife_out_l1[halflife_out_l1$HL==max_HL_l1, ]
      best_th_l1<-best_l1[1,2]
      
  #### LEVEL 2 
      # Calculate the new ranges for level 2 (this uses the stepsize that comes out of the branching function in level 1 )
      range_min_l2<-(best_th_l1-(step_size/2))
      range_max_l2<-(best_th_l1+(step_size/2))
      
      # Run the branch function 
      vals_l2<-branch_func(range_min = range_min_l2, range_max = range_max_l2, branch_num = 4)
      
       # Now run the model 
      for (i in 1:4){
        if (i==1){
          # Create empty list for results 
          level_2_results<<-list()
        }
        # Set current th 
        cur_th<-vals_l2[i]
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:25){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==11){
                env_func_1_1_par(days = 30, N= 1000, th_forage_sc = cur_th, daylight_h = 8, modelType = 11)
              }else if(model_type==21){
                env_func_2_1_par(days = 30, N= 1000, th_forage_fr = cur_th, daylight_h = 8, modelType = 21)
              }else if(model_type==31){
                env_func_3_1_par(days = 30, N= 1000, th_forage_flr = cur_th, daylight_h = 8, modelType = 31)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th)
          # add to list
          level_2_results[[i]]<<-mean_perf
        
        # mark that things are working
        print(paste("Done with level 2 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l2<-data.frame(matrix(unlist(level_2_results), nrow=4, byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th")
      colnames(halflife_out_l2)<-names
      
      # select highest outcome
      max_HL_l2<-max(halflife_out_l2$HL)
      best_l2<-halflife_out_l2[halflife_out_l2$HL==max_HL_l2, ]
      best_th_l2<-best_l2[1,2]
   
    #### LEVEL 3 
      # Calculate the new ranges for level 2 (this uses the stepsize that comes out of the branching function in level 1 )
      range_min_l3<-(best_th_l2-(step_size/2))
      range_max_l3<-(best_th_l2+(step_size/2))
      
      # Run the branch function 
      vals_l3<-branch_func(range_min = range_min_l3, range_max = range_max_l3, branch_num = 4)
      
       # Now run the model 
      for (i in 1:4){
        if (i==1){
          # Create empty list for results 
          level_3_results<<-list()
        }
        # Set current th 
        cur_th<-vals_l3[i]
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:25){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==11){
                env_func_1_1_par(days = 30, N= 1000, th_forage_sc = cur_th, daylight_h = 8, modelType = 11)
              }else if(model_type==21){
                env_func_2_1_par(days = 30, N= 1000, th_forage_fr = cur_th, daylight_h = 8, modelType = 21)
              }else if(model_type==31){
                env_func_3_1_par(days = 30, N= 1000, th_forage_flr = cur_th, daylight_h = 8, modelType = 31)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th)
          # add to list
          level_3_results[[i]]<<-mean_perf
        
        # mark that things are working
        print(paste("Done with level 3 ", i))
      } # end of 1-4 branching loop - level 3
      
      halflife_out_l3<-data.frame(matrix(unlist(level_3_results), nrow=4, byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL", "th")
      colnames(halflife_out_l3)<-names
      
      # select highest outcome
      max_HL_l3<-max(halflife_out_l3$HL)
      best_l3<-halflife_out_l3[halflife_out_l3$HL==max_HL_l3, ]
      best_th_l3<-best_l3[1,2]
      
      # Output the best threshold 
      return_list<-list(level_1_results, level_2_results, level_3_results, best_l3)
      return(return_list)

} # end of function 

```


### Run the new function 
```{r run the 4 branch x.1 function, include=T, message=F, warning=F}
return_list_11<-branch_4_optimization_x1(model_type = 11, range_min_start = 0, range_max_start = 0.4)

return_list_21<-branch_4_optimization_x1(model_type = 21, range_min_start = 0, range_max_start = 4)

return_list_31<-branch_4_optimization_x1(model_type = 31, range_min_start = -0.6, range_max_start = 0.6)
```

## Now make a function for the 2 threshold models 
```{r function for 2 thrshold models, include=T, message=F, warning=F}
branch_4_optimization_x2<-function(model_type, range_min_start_th1, range_max_start_th1, range_min_start_th2, range_max_start_th2){
  
  ##### LEVEL 1 
      # Run the branch function 
      vals_l1_th1<-branch_func(range_min = range_min_start_th1, range_max = range_max_start_th1, branch_num = 4)
      # save the stepsize used for this
      step_size_l1_th1<-step_size
      # run for second threshold 
      vals_l1_th2<-branch_func(range_min = range_min_start_th2, range_max = range_max_start_th2, branch_num = 4)
      # save the stepsize for this 
      step_size_l1_th2<-step_size
      
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l1_th1<-vals_l1_th1[1:4]
          vals_l1_th2<-vals_l1_th2[1:4]
          
          # Generate a grid with the possible combinations 
          l1_grid<-expand.grid(vals_l1_th1, vals_l1_th2)
          names<-c("th1", "th2")
          colnames(l1_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 
          l1_grid<-l1_grid[l1_grid$th1<l1_grid$th2, ]
      
      # Now run the model 
      for (i in 1:nrow(l1_grid)){
        if (i==1){
          # Create empty list for results 
          level_1_results<-list()
        }
        # Set current thresholds 
        cur_th1<-l1_grid[i,1]
        cur_th2<-l1_grid[i,2]
        
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:5){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==12){
                env_func_1_2_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , daylight_h = 8, modelType = 12)
              }else if(model_type==22){
                env_func_2_2_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , daylight_h = 8, modelType = 22)
              }else if(model_type==32){
                env_func_3_2_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , daylight_h = 8, modelType = 32)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=5, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2)
          # add to list
          level_1_results[[i]]<-mean_perf
          # mark that things are working
          print(paste("Done with level 1 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l1<-data.frame(matrix(unlist(level_1_results), nrow=nrow(l1_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2")
      colnames(halflife_out_l1)<-names
      
      # select highest outcome
      max_HL_l1<-max(halflife_out_l1$HL)
      best_l1<-halflife_out_l1[halflife_out_l1$HL==max_HL_l1, ]
      #best_ths_l1<-best_l1[1,2]
      
  #### LEVEL 2 
      # Calculate the new ranges for level 2 
          # For threshold 1 
          range_min_l2_th1<-(best_l1$th1-(step_size_l1_th1/2))
          range_max_l2_th1<-(best_l1$th1+(step_size_l1_th1/2))
          # Same for threshold 2
          range_min_l2_th2<-(best_l1$th2-(step_size_l1_th2/2))
          range_max_l2_th2<-(best_l1$th2+(step_size_l1_th2/2))
      
      # Run the branch function 
          # for th 1
          vals_l2_th1<-branch_func(range_min = range_min_l2_th1, range_max = range_max_l2_th1, branch_num = 4)
          # stepseize
          step_size_l2_th1<-step_size
          # run for th 2
          vals_l2_th2<-branch_func(range_min = range_min_l2_th2, range_max = range_max_l2_th2, branch_num = 4)
          # save the stepsize for later
          step_size_l2_th2<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l2_th1<-vals_l2_th1[1:4]
          vals_l2_th2<-vals_l2_th2[1:4]
          
          # Generate a grid with the possible combinations 
          l2_grid<-expand.grid(vals_l2_th1, vals_l2_th2)
          names<-c("th1", "th2")
          colnames(l2_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 
          l2_grid<-l2_grid[l2_grid$th1<l2_grid$th2, ]
      
       # Now run the model 
      for (i in 1:nrow(l2_grid)){
        if (i==1){
          # Create empty list for results 
          level_2_results<-list()
        }
        
        # Set current thresholds 
        cur_th1<-l2_grid[i,1]
        cur_th2<-l2_grid[i,2]
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:5){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==12){
                env_func_1_2_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , daylight_h = 8, modelType = 12)
              }else if(model_type==22){
                env_func_2_2_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , daylight_h = 8, modelType = 22)
              }else if(model_type==32){
                env_func_3_2_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , daylight_h = 8, modelType = 32)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=5, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2)
          # add to list
          level_2_results[[i]]<-mean_perf
        
        # mark that things are working
        print(paste("Done with level 2 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l2<-data.frame(matrix(unlist(level_2_results), nrow=nrow(l2_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2")
      colnames(halflife_out_l2)<-names
      
      # select highest outcome
      max_HL_l2<-max(halflife_out_l2$HL)
      best_l2<-halflife_out_l2[halflife_out_l2$HL==max_HL_l2, ]
     
   
    #### LEVEL 3 
      # Calculate the new ranges for level 2 
          # For threshold 1 
          range_min_l3_th1<-(best_l2$th1-(step_size_l2_th1/2))
          range_max_l3_th1<-(best_l2$th1+(step_size_l2_th1/2))
          # Same for threshold 2
          range_min_l3_th2<-(best_l2$th2-(step_size_l2_th2/2))
          range_max_l3_th2<-(best_l2$th2+(step_size_l2_th2/2))
      
      # Run the branch function 
          # for th 1
          vals_l3_th1<-branch_func(range_min = range_min_l3_th1, range_max = range_max_l3_th1, branch_num = 4)
          # stepseize
          step_size_l3_th1<-step_size
          # run for th 2
          vals_l3_th2<-branch_func(range_min = range_min_l3_th2, range_max = range_max_l3_th2, branch_num = 4)
          # save the stepsize for later
          step_size_l3_th2<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l3_th1<-vals_l3_th1[1:4]
          vals_l3_th2<-vals_l3_th2[1:4]
          
          # Generate a grid with the possible combinations 
          l3_grid<-expand.grid(vals_l3_th1, vals_l3_th2)
          names<-c("th1", "th2")
          colnames(l3_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 
          l3_grid<-l3_grid[l3_grid$th1<l3_grid$th2, ]
       
      # Now run the model 
        for (i in 1:nrow(l3_grid)){
          if (i==1){
            # Create empty list for results 
            level_3_results<-list()
          }
        # Set current thresholds 
        cur_th1<-l3_grid[i,1]
        cur_th2<-l3_grid[i,2]
          # Run the model 25 times in the 12 environments and take the average
            for (j in 1:5){
              if (j==1){
                out_per_run_list<-list()
              }
              # Run the model 
              if(model_type==12){
                env_func_1_2_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , daylight_h = 8, modelType = 12)
              }else if(model_type==22){
                env_func_2_2_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , daylight_h = 8, modelType = 22)
              }else if(model_type==32){
                env_func_3_2_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , daylight_h = 8, modelType = 32)
              }else{
                print('problem with model_type settings')
              }
            out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2)
            print(paste(j))
            } # end of loop for 25 run s
            
            # bind together
            out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=5, byrow=TRUE),stringsAsFactors=FALSE)
            colnames(out_per_run_df)<-"HL"
            # Now take the average for the threshold 
            mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2)
            # add to list
            level_3_results[[i]]<-mean_perf
          
          # mark that things are working
          print(paste("Done with level 3 ", i))
        } # end of 1-4 branching loop - level 3
      
      halflife_out_l3<-data.frame(matrix(unlist(level_3_results), nrow=nrow(l3_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL", "th1", "th2")
      colnames(halflife_out_l3)<-names
      
      # select highest outcome
      max_HL_l3<-max(halflife_out_l3$HL)
      best_l3<-halflife_out_l3[halflife_out_l3$HL==max_HL_l3, ]
  
      # Output the best threshold 
      return_list<-list(level_1_results, level_2_results, level_3_results, best_l3)
      return(return_list)

} # end of function 

# The HPC function 
branch_4_optimization_x2_hpc<-function(model_type, range_min_start_th1, range_max_start_th1, range_min_start_th2, range_max_start_th2){
  
  ##### LEVEL 1 
      # Run the branch function 
      vals_l1_th1<-branch_func(range_min = range_min_start_th1, range_max = range_max_start_th1, branch_num = 4)
      # save the stepsize used for this
      step_size_l1_th1<-step_size
      # run for second threshold 
      vals_l1_th2<-branch_func(range_min = range_min_start_th2, range_max = range_max_start_th2, branch_num = 4)
      # save the stepsize for this 
      step_size_l1_th2<-step_size
      
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l1_th1<-vals_l1_th1[1:4]
          vals_l1_th2<-vals_l1_th2[1:4]
          
          # Generate a grid with the possible combinations 
          l1_grid<-expand.grid(vals_l1_th1, vals_l1_th2)
          names<-c("th1", "th2")
          colnames(l1_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 
          l1_grid<-l1_grid[l1_grid$th1<l1_grid$th2, ]
      
      # Now run the model 
      for (i in 1:nrow(l1_grid)){
        if (i==1){
          # Create empty list for results 
          level_1_results<-list()
        }
        # Set current thresholds 
        cur_th1<-l1_grid[i,1]
        cur_th2<-l1_grid[i,2]
        
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:25){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==12){
                env_func_1_2_par_hpc(days = days, N=N , th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , daylight_h = daylight_h, modelType = 12)
              }else if(model_type==22){
                env_func_2_2_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , daylight_h = daylight_h, modelType = 22)
              }else if(model_type==32){
                env_func_3_2_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , daylight_h = daylight_h, modelType = 32)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2)
          # add to list
          level_1_results[[i]]<-mean_perf
          # mark that things are working
          print(paste("Done with level 1 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l1<-data.frame(matrix(unlist(level_1_results), nrow=nrow(l1_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2")
      colnames(halflife_out_l1)<-names
      
      # select highest outcome
      max_HL_l1<-max(halflife_out_l1$HL)
      best_l1<-halflife_out_l1[halflife_out_l1$HL==max_HL_l1, ]
      #best_ths_l1<-best_l1[1,2]
      
  #### LEVEL 2 
      # Calculate the new ranges for level 2 
          # For threshold 1 
          range_min_l2_th1<-(best_l1$th1-(step_size_l1_th1/2))
          range_max_l2_th1<-(best_l1$th1+(step_size_l1_th1/2))
          # Same for threshold 2
          range_min_l2_th2<-(best_l1$th2-(step_size_l1_th2/2))
          range_max_l2_th2<-(best_l1$th2+(step_size_l1_th2/2))
      
      # Run the branch function 
          # for th 1
          vals_l2_th1<-branch_func(range_min = range_min_l2_th1, range_max = range_max_l2_th1, branch_num = 4)
          # stepseize
          step_size_l2_th1<-step_size
          # run for th 2
          vals_l2_th2<-branch_func(range_min = range_min_l2_th2, range_max = range_max_l2_th2, branch_num = 4)
          # save the stepsize for later
          step_size_l2_th2<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l2_th1<-vals_l2_th1[1:4]
          vals_l2_th2<-vals_l2_th2[1:4]
          
          # Generate a grid with the possible combinations 
          l2_grid<-expand.grid(vals_l2_th1, vals_l2_th2)
          names<-c("th1", "th2")
          colnames(l2_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 
          l2_grid<-l2_grid[l2_grid$th1<l2_grid$th2, ]
      
       # Now run the model 
      for (i in 1:nrow(l2_grid)){
        if (i==1){
          # Create empty list for results 
          level_2_results<-list()
        }
        
        # Set current thresholds 
        cur_th1<-l2_grid[i,1]
        cur_th2<-l2_grid[i,2]
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:25){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==12){
                env_func_1_2_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , daylight_h = daylight_h, modelType = 12)
              }else if(model_type==22){
                env_func_2_2_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , daylight_h = daylight_h, modelType = 22)
              }else if(model_type==32){
                env_func_3_2_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , daylight_h = daylight_h, modelType = 32)
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2)
          # add to list
          level_2_results[[i]]<-mean_perf
        
        # mark that things are working
        print(paste("Done with level 2 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l2<-data.frame(matrix(unlist(level_2_results), nrow=nrow(l2_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2")
      colnames(halflife_out_l2)<-names
      
      # select highest outcome
      max_HL_l2<-max(halflife_out_l2$HL)
      best_l2<-halflife_out_l2[halflife_out_l2$HL==max_HL_l2, ]
     
   
    #### LEVEL 3 
      # Calculate the new ranges for level 2 
          # For threshold 1 
          range_min_l3_th1<-(best_l2$th1-(step_size_l2_th1/2))
          range_max_l3_th1<-(best_l2$th1+(step_size_l2_th1/2))
          # Same for threshold 2
          range_min_l3_th2<-(best_l2$th2-(step_size_l2_th2/2))
          range_max_l3_th2<-(best_l2$th2+(step_size_l2_th2/2))
      
      # Run the branch function 
          # for th 1
          vals_l3_th1<-branch_func(range_min = range_min_l3_th1, range_max = range_max_l3_th1, branch_num = 4)
          # stepseize
          step_size_l3_th1<-step_size
          # run for th 2
          vals_l3_th2<-branch_func(range_min = range_min_l3_th2, range_max = range_max_l3_th2, branch_num = 4)
          # save the stepsize for later
          step_size_l3_th2<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l3_th1<-vals_l3_th1[1:4]
          vals_l3_th2<-vals_l3_th2[1:4]
          
          # Generate a grid with the possible combinations 
          l3_grid<-expand.grid(vals_l3_th1, vals_l3_th2)
          names<-c("th1", "th2")
          colnames(l3_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 
          l3_grid<-l3_grid[l3_grid$th1<l3_grid$th2, ]
       
      # Now run the model 
        for (i in 1:nrow(l3_grid)){
          if (i==1){
            # Create empty list for results 
            level_3_results<-list()
          }
        # Set current thresholds 
        cur_th1<-l3_grid[i,1]
        cur_th2<-l3_grid[i,2]
          # Run the model 25 times in the 12 environments and take the average
            for (j in 1:5){
              if (j==1){
                out_per_run_list<-list()
              }
              # Run the model 
              if(model_type==12){
                env_func_1_2_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , daylight_h = daylight_h, modelType = 12)
              }else if(model_type==22){
                env_func_2_2_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , daylight_h = daylight_h, modelType = 22)
              }else if(model_type==32){
                env_func_3_2_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , daylight_h = daylight_h, modelType = 32)
              }else{
                print('problem with model_type settings')
              }
            out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2)
            print(paste(j))
            } # end of loop for 25 run s
            
            # bind together
            out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
            colnames(out_per_run_df)<-"HL"
            # Now take the average for the threshold 
            mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2)
            # add to list
            level_3_results[[i]]<-mean_perf
          
          # mark that things are working
          print(paste("Done with level 3 ", i))
        } # end of 1-4 branching loop - level 3
      
      halflife_out_l3<-data.frame(matrix(unlist(level_3_results), nrow=nrow(l3_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL", "th1", "th2")
      colnames(halflife_out_l3)<-names
      
      # select highest outcome
      max_HL_l3<-max(halflife_out_l3$HL)
      best_l3<-halflife_out_l3[halflife_out_l3$HL==max_HL_l3, ]
  
      # Output the best threshold 
      return_list<-list(level_1_results, level_2_results, level_3_results, best_l3)
      return(return_list)

} # end of function for hpc 


```

### Run the function 
```{r run x.2 models function, include=T, warning=F, message=F}
return_list_12<-branch_4_optimization_x2(model_type=12, range_min_start_th1=0, range_max_start_th1=0.4, range_min_start_th2=0, range_max_start_th2 = 0.4)

return_list_22<-branch_4_optimization_x2(model_type=22, range_min_start_th1=0, range_max_start_th1=4, range_min_start_th2=0, range_max_start_th2 = 4)

return_list_32<-branch_4_optimization_x2(model_type=32, range_min_start_th1=-0.6, range_max_start_th1=0.6, range_min_start_th2=-0.6, range_max_start_th2 = 0.6)


```

## Now make the functions for the x.3 models 
```{r function for 3 thrshold models, include=T, message=F, warning=F}
branch_4_optimization_x3<-function(model_type, range_min_start_th1, range_max_start_th1, range_min_start_th2, range_max_start_th2, range_min_start_th3, range_max_start_th3){
  
  ##### LEVEL 1 
      # Run the branch function 
      vals_l1_th1<-branch_func(range_min = range_min_start_th1, range_max = range_max_start_th1, branch_num = 4)
      # save the stepsize used for this
      step_size_l1_th1<-step_size
      # run for second threshold 
      vals_l1_th2<-branch_func(range_min = range_min_start_th2, range_max = range_max_start_th2, branch_num = 4)
      # save the stepsize for this 
      step_size_l1_th2<-step_size
      # run for thrid threshold 
      vals_l1_th3<-branch_func(range_min = range_min_start_th3, range_max = range_max_start_th3, branch_num = 4)
      # save the stepsize for this 
      step_size_l1_th3<-step_size
      
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l1_th1<-vals_l1_th1[1:4]
          vals_l1_th2<-vals_l1_th2[1:4]
          vals_l1_th3<-vals_l1_th3[1:4]
          
          # Generate a grid with the possible combinations 
          l1_grid<-expand.grid(vals_l1_th1, vals_l1_th2, vals_l1_th3)
          names<-c("th1", "th2", "th3")
          colnames(l1_grid)<-names
          
          # For models x.2 of the first subset, th2 needs to be higher than th1 and th3 higher than th2
          l1_grid<-l1_grid[((l1_grid$th1<l1_grid$th2)&(l1_grid$th3>l1_grid$th2)), ]
      
      # Now run the model 
      for (i in 1:nrow(l1_grid)){
        if (i==1){
          # Create empty list for results 
          level_1_results<-list()
        }
        # Set current thresholds 
        cur_th1<-l1_grid[i,1]
        cur_th2<-l1_grid[i,2]
        cur_th3<-l1_grid[i,3]
        
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:5){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==131){
                env_func_1_3_1_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = 8, modelType = 131)
                
              }else if(model_type==132){
                env_func_1_3_2_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = 8, modelType = 132)
                
              }else if(model_type==231){
                env_func_2_3_1_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = 8, modelType = 231)
                
              }else if(model_type==232){
                env_func_2_3_2_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = 8, modelType = 232)
                
              }else if(model_type==331){
                env_func_3_3_1_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = 8, modelType = 331)
                
              }else if(model_type==332){
                  env_func_3_3_2_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = 8, modelType = 332)
                
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2, cur_th3)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=5, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2, cur_th3)
          # add to list
          level_1_results[[i]]<-mean_perf
          # mark that things are working
          print(paste("Done with level 1 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l1<-data.frame(matrix(unlist(level_1_results), nrow=nrow(l1_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2", "th3")
      colnames(halflife_out_l1)<-names
      
      # select highest outcome
      max_HL_l1<-max(halflife_out_l1$HL)
      best_l1<-halflife_out_l1[halflife_out_l1$HL==max_HL_l1, ]
      #best_ths_l1<-best_l1[1,2]
      
  #### LEVEL 2 
      # Calculate the new ranges for level 2 
          # For threshold 1 
          range_min_l2_th1<-(best_l1$th1-(step_size_l1_th1/2))
          range_max_l2_th1<-(best_l1$th1+(step_size_l1_th1/2))
          # Same for threshold 2
          range_min_l2_th2<-(best_l1$th2-(step_size_l1_th2/2))
          range_max_l2_th2<-(best_l1$th2+(step_size_l1_th2/2))
          # and threshold 3
          range_min_l2_th3<-(best_l1$th3-(step_size_l1_th3)/2)
          range_max_l2_th3<-(best_l1$th3+(step_size_l1_th3)/2)
      
      # Run the branch function 
          vals_l2_th1<-branch_func(range_min = range_min_l2_th1, range_max = range_max_l2_th1, branch_num = 4)
          # save the stepsize used for this
          step_size_l2_th1<-step_size
          # run for second threshold 
          vals_l2_th2<-branch_func(range_min = range_min_l2_th2, range_max = range_max_l2_th2, branch_num = 4)
          # save the stepsize for this 
          step_size_l2_th2<-step_size
          # run for thrid threshold 
          vals_l2_th3<-branch_func(range_min = range_min_l2_th3, range_max = range_max_l2_th3, branch_num = 4)
          # save the stepsize for this 
          step_size_l2_th3<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l2_th1<-vals_l2_th1[1:4]
          vals_l2_th2<-vals_l2_th2[1:4]
          vals_l2_th3<-vals_l2_th3[1:4]
          
          # Generate a grid with the possible combinations 
          l2_grid<-expand.grid(vals_l2_th1, vals_l2_th2, vals_l2_th3)
          names<-c("th1", "th2", "th3")
          colnames(l2_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 and th3 higher than th2 
          l2_grid<-l2_grid[((l2_grid$th1<l2_grid$th2)&(l2_grid$th3>l2_grid$th2)), ]
      
      # Now run the model 
      for (i in 1:nrow(l2_grid)){
        if (i==1){
          # Create empty list for results 
          level_2_results<-list()
        }
        
        # Set current thresholds 
        cur_th1<-l2_grid[i,1]
        cur_th2<-l2_grid[i,2]
        cur_th3<-l2_grid[i,3]
        
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:5){
            if (j==1){
              out_per_run_list<-list()
            }
         # Run the model 
              if(model_type==131){
                env_func_1_3_1_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = 8, modelType = 131)
                
              }else if(model_type==132){
                env_func_1_3_2_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = 8, modelType = 132)
                
              }else if(model_type==231){
                env_func_2_3_1_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = 8, modelType = 231)
                
              }else if(model_type==232){
                env_func_2_3_2_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = 8, modelType = 232)
                
              }else if(model_type==331){
                env_func_3_3_1_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = 8, modelType = 331)
                
              }else if(model_type==332){
                  env_func_3_3_2_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = 8, modelType = 332)
                
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2, cur_th3)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=5, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2, cur_th3)
          # add to list
          level_2_results[[i]]<-mean_perf
        
        # mark that things are working
        print(paste("Done with level 2 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l2<-data.frame(matrix(unlist(level_2_results), nrow=nrow(l2_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2", "th3")
      colnames(halflife_out_l2)<-names
      
      # select highest outcome
      max_HL_l2<-max(halflife_out_l2$HL)
      best_l2<-halflife_out_l2[halflife_out_l2$HL==max_HL_l2, ]
     
   
    #### LEVEL 3 
      # Calculate the new ranges for level 3
          # For threshold 1 
          range_min_l3_th1<-(best_l2$th1-(step_size_l2_th1/2))
          range_max_l3_th1<-(best_l2$th1+(step_size_l2_th1/2))
          # Same for threshold 2
          range_min_l3_th2<-(best_l2$th2-(step_size_l2_th2/2))
          range_max_l3_th2<-(best_l2$th2+(step_size_l2_th2/2))
          # and threshold 3
          range_min_l3_th3<-(best_l2$th3-(step_size_l2_th3)/2)
          range_max_l3_th3<-(best_l2$th3+(step_size_l2_th3)/2)
      
      
      # Run the branch function 
          # for th 1
          vals_l3_th1<-branch_func(range_min = range_min_l3_th1, range_max = range_max_l3_th1, branch_num = 4)
          # stepseize
          step_size_l3_th1<-step_size
          # run for th 2
          vals_l3_th2<-branch_func(range_min = range_min_l3_th2, range_max = range_max_l3_th2, branch_num = 4)
          # save the stepsize for later
          step_size_l3_th2<-step_size
          # run for thrid threshold 
          vals_l3_th3<-branch_func(range_min = range_min_l3_th3, range_max = range_max_l3_th3, branch_num = 4)
          # save the stepsize for this 
          step_size_l3_th3<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l3_th1<-vals_l3_th1[1:4]
          vals_l3_th2<-vals_l3_th2[1:4]
          vals_l3_th3<-vals_l3_th3[1:4]
          
          # Generate a grid with the possible combinations 
          l3_grid<-expand.grid(vals_l3_th1, vals_l3_th2, vals_l3_th3)
          names<-c("th1", "th2", "th3")
          colnames(l3_grid)<-names
          
          # For models x.2 of the first subset, th2 needs to be higher than th1 and th3 higher than th2
          l3_grid<-l3_grid[((l2_grid$th1<l3_grid$th2)&(l3_grid$th3>l3_grid$th2)), ]
       
      # Now run the model 
        for (i in 1:nrow(l3_grid)){
          if (i==1){
            # Create empty list for results 
            level_3_results<-list()
          }
        # Set current thresholds 
        cur_th1<-l3_grid[i,1]
        cur_th2<-l3_grid[i,2]
        cur_th3<-l3_grid[i,3]
          # Run the model 25 times in the 12 environments and take the average
            for (j in 1:5){
              if (j==1){
                out_per_run_list<-list()
              }
       # Run the model 
              if(model_type==131){
                env_func_1_3_1_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = 8, modelType = 131)
                
              }else if(model_type==132){
                env_func_1_3_2_par(days = 10, N= 100, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = 8, modelType = 132)
                
              }else if(model_type==231){
                env_func_2_3_1_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = 8, modelType = 231)
                
              }else if(model_type==232){
                env_func_2_3_2_par(days = 10, N= 100, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = 8, modelType = 232)
                
              }else if(model_type==331){
                env_func_3_3_1_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = 8, modelType = 331)
                
              }else if(model_type==332){
                  env_func_3_3_2_par(days = 10, N= 100, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = 8, modelType = 332)
                
              }else{
                print('problem with model_type settings')
              }
            # add the output 
            out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2, cur_th3)
            print(paste(j))
            } # end of loop for 25 run s
            
            # bind together
            out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=5, byrow=TRUE),stringsAsFactors=FALSE)
            colnames(out_per_run_df)<-"HL"
            # Now take the average for the threshold 
            mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2, cur_th3)
            # add to list
            level_3_results[[i]]<-mean_perf
          
          # mark that things are working
          print(paste("Done with level 3 ", i))
        } # end of 1-4 branching loop - level 3
      
      halflife_out_l3<-data.frame(matrix(unlist(level_3_results), nrow=nrow(l3_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL", "th1", "th2", "th3")
      colnames(halflife_out_l3)<-names
      
      # select highest outcome
      max_HL_l3<-max(halflife_out_l3$HL)
      best_l3<-halflife_out_l3[halflife_out_l3$HL==max_HL_l3, ]
  
      # Output the best threshold 
      return_list<-list(level_1_results, level_2_results, level_3_results, best_l3)
      return(return_list)

} # end of function 


# For use on the HPC
branch_4_optimization_x3_hpc<-function(model_type, range_min_start_th1, range_max_start_th1, range_min_start_th2, range_max_start_th2, range_min_start_th3, range_max_start_th3){
  
  ##### LEVEL 1 
      # Run the branch function 
      vals_l1_th1<-branch_func(range_min = range_min_start_th1, range_max = range_max_start_th1, branch_num = 4)
      # save the stepsize used for this
      step_size_l1_th1<-step_size
      # run for second threshold 
      vals_l1_th2<-branch_func(range_min = range_min_start_th2, range_max = range_max_start_th2, branch_num = 4)
      # save the stepsize for this 
      step_size_l1_th2<-step_size
      # run for thrid threshold 
      vals_l1_th3<-branch_func(range_min = range_min_start_th3, range_max = range_max_start_th3, branch_num = 4)
      # save the stepsize for this 
      step_size_l1_th3<-step_size
      
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l1_th1<-vals_l1_th1[1:4]
          vals_l1_th2<-vals_l1_th2[1:4]
          vals_l1_th3<-vals_l1_th3[1:4]
          
          # Generate a grid with the possible combinations 
          l1_grid<-expand.grid(vals_l1_th1, vals_l1_th2, vals_l1_th3)
          names<-c("th1", "th2", "th3")
          colnames(l1_grid)<-names
          
          # For models x.2 of the first subset, th2 needs to be higher than th1 and th3 higher than th2
          l1_grid<-l1_grid[((l1_grid$th1<l1_grid$th2)&(l1_grid$th3>l1_grid$th2)), ]
      
      # Now run the model 
      for (i in 1:nrow(l1_grid)){
        if (i==1){
          # Create empty list for results 
          level_1_results<-list()
        }
        # Set current thresholds 
        cur_th1<-l1_grid[i,1]
        cur_th2<-l1_grid[i,2]
        cur_th3<-l1_grid[i,3]
        
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:25){
            if (j==1){
              out_per_run_list<-list()
            }
            # Run the model 
              if(model_type==131){
                env_func_1_3_1_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = daylight_h, modelType = 131)
              }else if(model_type==132){
                env_func_1_3_2_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = daylight_h, modelType = 132)
                
              }else if(model_type==231){
                env_func_2_3_1_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = daylight_h, modelType = 231)
                
              }else if(model_type==232){
                env_func_2_3_2_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = daylight_h, modelType = 232)
                
              }else if(model_type==331){
                env_func_3_3_1_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = daylight_h, modelType = 331)
                
              }else if(model_type==332){
                  env_func_3_3_2_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = daylight_h, modelType = 332)
                
              }else{
                print('problem with model_type settings')
              }
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2, cur_th3)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2, cur_th3)
          # add to list
          level_1_results[[i]]<-mean_perf
          # mark that things are working
          print(paste("Done with level 1 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l1<-data.frame(matrix(unlist(level_1_results), nrow=nrow(l1_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2", "th3")
      colnames(halflife_out_l1)<-names
      
      # select highest outcome
      max_HL_l1<-max(halflife_out_l1$HL)
      best_l1<-halflife_out_l1[halflife_out_l1$HL==max_HL_l1, ]
      #best_ths_l1<-best_l1[1,2]
      
  #### LEVEL 2 
      # Calculate the new ranges for level 2 
          # For threshold 1 
          range_min_l2_th1<-(best_l1$th1-(step_size_l1_th1/2))
          range_max_l2_th1<-(best_l1$th1+(step_size_l1_th1/2))
          # Same for threshold 2
          range_min_l2_th2<-(best_l1$th2-(step_size_l1_th2/2))
          range_max_l2_th2<-(best_l1$th2+(step_size_l1_th2/2))
          # and threshold 3
          range_min_l2_th3<-(best_l1$th3-(step_size_l1_th3)/2)
          range_max_l2_th3<-(best_l1$th3+(step_size_l1_th3)/2)
      
      # Run the branch function 
          vals_l2_th1<-branch_func(range_min = range_min_l2_th1, range_max = range_max_l2_th1, branch_num = 4)
          # save the stepsize used for this
          step_size_l2_th1<-step_size
          # run for second threshold 
          vals_l2_th2<-branch_func(range_min = range_min_l2_th2, range_max = range_max_l2_th2, branch_num = 4)
          # save the stepsize for this 
          step_size_l2_th2<-step_size
          # run for thrid threshold 
          vals_l2_th3<-branch_func(range_min = range_min_l2_th3, range_max = range_max_l2_th3, branch_num = 4)
          # save the stepsize for this 
          step_size_l2_th3<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l2_th1<-vals_l2_th1[1:4]
          vals_l2_th2<-vals_l2_th2[1:4]
          vals_l2_th3<-vals_l2_th3[1:4]
          
          # Generate a grid with the possible combinations 
          l2_grid<-expand.grid(vals_l2_th1, vals_l2_th2, vals_l2_th3)
          names<-c("th1", "th2", "th3")
          colnames(l2_grid)<-names
          
          # For models x.1 of the first subset, th2 needs to be higher than th1 and th3 higher than th2 
          l2_grid<-l2_grid[((l2_grid$th1<l2_grid$th2)&(l2_grid$th3>l2_grid$th2)), ]
      
      # Now run the model 
      for (i in 1:nrow(l2_grid)){
        if (i==1){
          # Create empty list for results 
          level_2_results<-list()
        }
        
        # Set current thresholds 
        cur_th1<-l2_grid[i,1]
        cur_th2<-l2_grid[i,2]
        cur_th3<-l2_grid[i,3]
        
        # Run the model 25 times in the 12 environments and take the average
          for (j in 1:5){
            if (j==1){
              out_per_run_list<-list()
            }
         # Run the model 
              if(model_type==131){
                env_func_1_3_1_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = daylight_h, modelType = 131)
              }else if(model_type==132){
                env_func_1_3_2_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = daylight_h, modelType = 132)
                
              }else if(model_type==231){
                env_func_2_3_1_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = daylight_h, modelType = 231)
                
              }else if(model_type==232){
                env_func_2_3_2_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = daylight_h, modelType = 232)
                
              }else if(model_type==331){
                env_func_3_3_1_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = daylight_h, modelType = 331)
                
              }else if(model_type==332){
                  env_func_3_3_2_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = daylight_h, modelType = 332)
                
              }else{
                print('problem with model_type settings')
              }
          # add the outcome 
          out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2, cur_th3)
          print(paste(j))
          } # end of loop for 25 run s
          
          # bind together
          out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
          colnames(out_per_run_df)<-"HL"
          # Now take the average for the threshold 
          mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2, cur_th3)
          # add to list
          level_2_results[[i]]<-mean_perf
        
        # mark that things are working
        print(paste("Done with level 2 ", i))
      } # end of 1-4 branching loop
      
      halflife_out_l2<-data.frame(matrix(unlist(level_2_results), nrow=nrow(l2_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL",  "th1", "th2", "th3")
      colnames(halflife_out_l2)<-names
      
      # select highest outcome
      max_HL_l2<-max(halflife_out_l2$HL)
      best_l2<-halflife_out_l2[halflife_out_l2$HL==max_HL_l2, ]
     
   
    #### LEVEL 3 
      # Calculate the new ranges for level 3
          # For threshold 1 
          range_min_l3_th1<-(best_l2$th1-(step_size_l2_th1/2))
          range_max_l3_th1<-(best_l2$th1+(step_size_l2_th1/2))
          # Same for threshold 2
          range_min_l3_th2<-(best_l2$th2-(step_size_l2_th2/2))
          range_max_l3_th2<-(best_l2$th2+(step_size_l2_th2/2))
          # and threshold 3
          range_min_l3_th3<-(best_l2$th3-(step_size_l2_th3)/2)
          range_max_l3_th3<-(best_l2$th3+(step_size_l2_th3)/2)
      
      
      # Run the branch function 
          # for th 1
          vals_l3_th1<-branch_func(range_min = range_min_l3_th1, range_max = range_max_l3_th1, branch_num = 4)
          # stepseize
          step_size_l3_th1<-step_size
          # run for th 2
          vals_l3_th2<-branch_func(range_min = range_min_l3_th2, range_max = range_max_l3_th2, branch_num = 4)
          # save the stepsize for later
          step_size_l3_th2<-step_size
          # run for thrid threshold 
          vals_l3_th3<-branch_func(range_min = range_min_l3_th3, range_max = range_max_l3_th3, branch_num = 4)
          # save the stepsize for this 
          step_size_l3_th3<-step_size
          
      # Generate the possible combinations 
          # Take out the stepsize 
          vals_l3_th1<-vals_l3_th1[1:4]
          vals_l3_th2<-vals_l3_th2[1:4]
          vals_l3_th3<-vals_l3_th3[1:4]
          
          # Generate a grid with the possible combinations 
          l3_grid<-expand.grid(vals_l3_th1, vals_l3_th2, vals_l3_th3)
          names<-c("th1", "th2", "th3")
          colnames(l3_grid)<-names
          
          # For models x.2 of the first subset, th2 needs to be higher than th1 and th3 higher than th2
          l3_grid<-l3_grid[((l2_grid$th1<l3_grid$th2)&(l3_grid$th3>l3_grid$th2)), ]
       
      # Now run the model 
        for (i in 1:nrow(l3_grid)){
          if (i==1){
            # Create empty list for results 
            level_3_results<-list()
          }
        # Set current thresholds 
        cur_th1<-l3_grid[i,1]
        cur_th2<-l3_grid[i,2]
        cur_th3<-l3_grid[i,3]
          # Run the model 25 times in the 12 environments and take the average
            for (j in 1:5){
              if (j==1){
                out_per_run_list<-list()
              }
    # Run the model 
              if(model_type==131){
                env_func_1_3_1_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = daylight_h, modelType = 131)
              }else if(model_type==132){
                env_func_1_3_2_par_hpc(days = days, N= N, th_forage_sc1 = cur_th1 , th_forage_sc2 = cur_th2 , th_forage_sc3 = cur_th3, daylight_h = daylight_h, modelType = 132)
                
              }else if(model_type==231){
                env_func_2_3_1_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = daylight_h, modelType = 231)
                
              }else if(model_type==232){
                env_func_2_3_2_par_hpc(days = days, N= N, th_forage_fr1 = cur_th1 , th_forage_fr2 = cur_th2 , th_forage_fr3 = cur_th3, daylight_h = daylight_h, modelType = 232)
                
              }else if(model_type==331){
                env_func_3_3_1_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = daylight_h, modelType = 331)
                
              }else if(model_type==332){
                  env_func_3_3_2_par_hpc(days = days, N= N, th_forage_flr1 = cur_th1 , th_forage_flr2 = cur_th2 , th_forage_flr3 = cur_th3, daylight_h = daylight_h, modelType = 332)
                
              }else{
                print('problem with model_type settings')
              }
            # add the output 
            out_per_run_list[j]<-cbind(output_env_func[[1]][1], cur_th1, cur_th2, cur_th3)
            print(paste(j))
            } # end of loop for 25 run s
            
            # bind together
            out_per_run_df<-data.frame(matrix(unlist(out_per_run_list), nrow=25, byrow=TRUE),stringsAsFactors=FALSE)
            colnames(out_per_run_df)<-"HL"
            # Now take the average for the threshold 
            mean_perf<-c(mean(out_per_run_df$HL), cur_th1, cur_th2, cur_th3)
            # add to list
            level_3_results[[i]]<-mean_perf
          
          # mark that things are working
          print(paste("Done with level 3 ", i))
        } # end of 1-4 branching loop - level 3
      
      halflife_out_l3<-data.frame(matrix(unlist(level_3_results), nrow=nrow(l3_grid), byrow=TRUE),stringsAsFactors=FALSE)
      names<-c("HL", "th1", "th2", "th3")
      colnames(halflife_out_l3)<-names
      
      # select highest outcome
      max_HL_l3<-max(halflife_out_l3$HL)
      best_l3<-halflife_out_l3[halflife_out_l3$HL==max_HL_l3, ]
  
      # Output the best threshold 
      return_list<-list(level_1_results, level_2_results, level_3_results, best_l3)
      return(return_list)

} # end of function for hpc 


```

## Run the function 
```{r run x.3 models function, include=T, warning=F, message=F}
return_list_131<-branch_4_optimization_x3(model_type=131, range_min_start_th1=0, range_max_start_th1=0.4, range_min_start_th2=0, range_max_start_th2 = 0.4,  range_min_start_th3=0, range_max_start_th3 = 0.4)

return_list_132<-branch_4_optimization_x3(model_type=132, range_min_start_th1=0, range_max_start_th1=0.4, range_min_start_th2=0, range_max_start_th2 = 0.4,  range_min_start_th3=0, range_max_start_th3 = 0.4)

return_list_231<-branch_4_optimization_x3(model_type=231, range_min_start_th1=0, range_max_start_th1=4, range_min_start_th2=0, range_max_start_th2 = 4,  range_min_start_th3=0, range_max_start_th3 = 4)

return_list_232<-branch_4_optimization_x3(model_type=232, range_min_start_th1=0, range_max_start_th1=4, range_min_start_th2=0, range_max_start_th2 = 4,  range_min_start_th3=0, range_max_start_th3 = 4)

return_list_331<-branch_4_optimization_x3(model_type=331, range_min_start_th1=-0.6, range_max_start_th1=0.6, range_min_start_th2=-0.6, range_max_start_th2 = 0.6,  range_min_start_th3=-0.6, range_max_start_th3 = 0.6)

return_list_332<-branch_4_optimization_x3(model_type=332, range_min_start_th1=-0.6, range_max_start_th1=0.6, range_min_start_th2=-0.6, range_max_start_th2 = 0.6,  range_min_start_th3=-0.6, range_max_start_th3 = 0.6)

```


## January 2024: rewrite the tree-functions 
I re-wrote the x.2 function and the x.3 function 
Run them here: 
```{r run x.3, include=T, echo=F, message=F, eval=T}
out_x3<-tree_func_x3(start_min_th1 = 0, start_max_th1 = 0.4, start_min_th2 = 0, start_max_th2 = 0.4, start_min_th3 = 0, start_max_th3 = 0.4, branch_num = 4)

```

Then, I worked on the second subset of moels: they have 2 variables that decisions are based on. 

Start with the simplest model: a non-hoarding bird, access to 2 variables, each with 1 threshold. 
The v's in the code stand for 'variable' (e.g. stmac content), the 'th' in the code are for 'threshold number'. So for example, a model with both SC and FR, each with 3 thresholds would have v1 (SC) and v3 (FR). For each of those there would be a th1, th2 and th3. 
```{r make subset 2 x.1 models}

# Non hoarder 2 variables 
    tree_func_sub2_x1<-function(start_min_v1_th1, start_max_v1_th1, start_min_v2_th1, start_max_v2_th1, branch_num){
      depth<-3
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_v1_th1<-branch_func(range_min = start_min_v1_th1, range_max = start_max_v1_th1, branch_num = branch_num)
              out_v2_th1<-branch_func(range_min= start_min_v2_th1, range_max = start_max_v2_th1, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], out_v2_th1[branch_num+1]))
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_v1_th1[1:branch_num], out_v2_th1[1:branch_num])
              colnames(grid)<-c("v1_th1", "v2_th1")
            # Subset this for cases where th2 > th 1 
              #grid<-grid%>%
                #filter(th1<th2)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
          }else if(i==2){
            # So for level 2
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_v1_th1<-(tree_output_list[[i-1]][[1]][[j]]-(0.5*stepsize_list[[i-1]][[1]]))
                  cur_min_v2_th1<-(tree_output_list[[i-1]][[2]][[j]]-(0.5*stepsize_list[[i-1]][[2]]))
                  # calculate the new maximum 
                  cur_max_v1_th1<-(tree_output_list[[i-1]][[1]][[j]]+(0.5*stepsize_list[[i-1]][[1]]))
                  cur_max_v2_th1<-(tree_output_list[[i-1]][[2]][[j]]+(0.5*stepsize_list[[i-1]][[2]]))
            
                  # run the function 
                  out_v1_th1<-branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)
                  out_v2_th1<-branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], out_v2_th1[branch_num+1]))
      
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_v1_th1[1:branch_num], out_v2_th1[1:branch_num])
                  colnames(grid)<-c("v1_th1", "v2_th1")
                  # Subset this for cases where th2 > th 1 
                  #grid<-grid%>%
                    #filter(th1<th2)
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  
              }
            # sort naming 
            names(level_list)<-c(
                                        (paste(tree_output_list[[1]][[1]][[1]], "&", tree_output_list[[1]][[2]][[1]])), 
                                        (paste(tree_output_list[[1]][[1]][[2]], "&", tree_output_list[[1]][[2]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[3]], "&", tree_output_list[[1]][[2]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[4]], "&", tree_output_list[[1]][[2]][[4]])),
                                        (paste(tree_output_list[[1]][[1]][[5]], "&", tree_output_list[[1]][[2]][[5]])),
                                        (paste(tree_output_list[[1]][[1]][[6]], "&", tree_output_list[[1]][[2]][[6]])),
                                        (paste(tree_output_list[[1]][[1]][[7]], "&", tree_output_list[[1]][[2]][[7]])), 
                                        (paste(tree_output_list[[1]][[1]][[8]], "&", tree_output_list[[1]][[2]][[8]])),
                                        (paste(tree_output_list[[1]][[1]][[9]], "&", tree_output_list[[1]][[2]][[9]])),
                                        (paste(tree_output_list[[1]][[1]][[10]], "&", tree_output_list[[1]][[2]][[10]])),
                                        (paste(tree_output_list[[1]][[1]][[11]], "&", tree_output_list[[1]][[2]][[11]])),
                                        (paste(tree_output_list[[1]][[1]][[12]], "&", tree_output_list[[1]][[2]][[12]])),
                                        (paste(tree_output_list[[1]][[1]][[13]], "&", tree_output_list[[1]][[2]][[13]])), 
                                        (paste(tree_output_list[[1]][[1]][[14]], "&", tree_output_list[[1]][[2]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[15]], "&", tree_output_list[[1]][[2]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[16]], "&", tree_output_list[[1]][[2]][[4]])))

                                        
                                        
                                        
                                        
                                        )
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j
            
          }else if(i==3){
            # For level 3 
            # This can't be the same as 2, because the structure of teh list won't be the same 
            # For any additional levels this would probably be teh case. 
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[i-1]][[1]]))
                      cur_min_th2<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[i-1]][[2]]))
                      # calculate the new maximum 
                      cur_max_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[i-1]][[1]]))
                      cur_max_th2<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[i-1]][[2]]))
                
                      # run the function 
                      out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                      out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list[[i]]<-as.data.frame(cbind(out_th1[5], out_th2[5]))
      
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_th1[1:4], out_th2[1:4])
                      colnames(grid)<-c("th1", "th2")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                        filter(th1<th2)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                  }
                   # sort naming 
                    names(list_new_th)<-c(
                                        (paste(tree_output_list[[2]][[1]][[1]][[1]], "&", tree_output_list[[2]][[1]][[2]][[1]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[2]], "&", tree_output_list[[2]][[1]][[2]][[2]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[3]], "&", tree_output_list[[2]][[1]][[2]][[3]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[4]], "&", tree_output_list[[2]][[1]][[2]][[4]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[5]], "&", tree_output_list[[2]][[1]][[2]][[5]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[6]], "&", tree_output_list[[2]][[1]][[2]][[6]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[7]], "&", tree_output_list[[2]][[1]][[2]][[7]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[8]], "&", tree_output_list[[2]][[1]][[2]][[8]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[9]], "&", tree_output_list[[2]][[1]][[2]][[9]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[10]], "&", tree_output_list[[2]][[1]][[2]][[10]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[11]], "&", tree_output_list[[2]][[1]][[2]][[11]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[12]], "&", tree_output_list[[2]][[1]][[2]][[12]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[13]], "&", tree_output_list[[2]][[1]][[2]][[13]])), 
                                        (paste(tree_output_list[[2]][[1]][[1]][[14]], "&", tree_output_list[[2]][[1]][[2]][[14]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[15]], "&", tree_output_list[[2]][[1]][[2]][[15]])),
                                        (paste(tree_output_list[[2]][[1]][[1]][[16]], "&", tree_output_list[[2]][[1]][[2]][[16]]))
                                        )
              
              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
            }
            # sort naming 
            names(level_list)<-c(
                                        (paste(tree_output_list[[1]][[1]][[1]], "&", tree_output_list[[1]][[2]][[1]])), 
                                        (paste(tree_output_list[[1]][[1]][[2]], "&", tree_output_list[[1]][[2]][[2]])),
                                        (paste(tree_output_list[[1]][[1]][[3]], "&", tree_output_list[[1]][[2]][[3]])),
                                        (paste(tree_output_list[[1]][[1]][[4]], "&", tree_output_list[[1]][[2]][[4]])),
                                        (paste(tree_output_list[[1]][[1]][[5]], "&", tree_output_list[[1]][[2]][[5]])),
                                        (paste(tree_output_list[[1]][[1]][[6]], "&", tree_output_list[[1]][[2]][[6]])))
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
          }
        
      } # end the for loop 
   names(tree_output_list)<-c("level1", "level2", "level3")
   return(tree_output_list)
} # End hte function 
   



```




