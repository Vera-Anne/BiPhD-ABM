---
title: "Concatenate level outcome from HPC + prep new dataframe for next level"
author: "Vera Vinken"
date: "`r Sys.Date()`"
output: html_document
---
  
## Packages 

```{r packages, include=TRUE, message=FALSE, warning=FALSE}
library(stringr)      # to select the 2nd digit of a number with the str_sub() function 
library(parallel)     # parallel computing 
library(doParallel)   # parallel computing 
library(dplyr)        # For %>% pipes
```

## Background
This code will take the output from the HPC from a specific level. It then concatenates this and calculates the mean survival for each threshold combination across the 25 repetitions. The best threshold combination of the level is selected. With this, a new dataframe is prepared for hte next level, containig a combination of thrsholds per row. This is all saved automatically. 


## Basic settings 
```{r settings}
model_type<-21
level<-1          # The level that you are concatenating (the level that just ran on the HPC) - put 0 if you want to generate for level 1 
subset<-1

```

## Set working directories 
```{r set working directories}
general_folder<-"C:/Users/c0070955/OneDrive - Newcastle University/1-PHD-project/Modelling/HPC/predesigned_branches"

```

## Set working directory & Load HPC output data 
This is only necessary when you are concatenating (so only for levels 2 and 3)
```{r load data}
# set working directory depending on model type

cur_wd<-(paste0(general_folder,"/output_subset", subset, "/level_", level, "/", model_type, "/"))

setwd(cur_wd)

# Load data 
  # Note that I use a parallel appraoch which won't be necessary until I'm dealing which large numbers of files
  # This will be relevant for the second subset mostly. 

  # Load the filenames in this folder 
  filenames <- list.files(pattern="*.Rda", full.names=TRUE)
  # make halflife list
  halflife_list<-list()
  # Set up for parallel processing
  numCores<-(detectCores()-1)
  registerDoParallel(numCores)
  # Loop through each datafile 
  outcome_concat<- foreach(j=1:length(filenames), .combine='c') %dopar% {
    # For each of the files in the current batch: extract the halflife 
    # load the current file 
    load(filenames[j])
    # extract the current halflife and put in list 
    halflife_list[1]<-env_results[1]                                # add performance              
    halflife_list[[1]][3]<-env_results[[3]]$th_row                  # add the row of dataframe 
    halflife_list[[1]][4]<-env_results[[3]]$rep_num                 # Add the rep number 
    halflife_list[[1]][5:(length(env_results[[3]])-4)] <-env_results[[3]][9:length(env_results[[3]])]  # add the actual thresholds 
    # Add the list to the outcome_concat 
    halflife_list
  } # end for loop that runs through files in a batch-folder
  
  # stop the cluster
  stopImplicitCluster()
```

## Find best combo 
Concatenate the data, summarise across the 25 repetitions, and find the combination with the best survival output 

```{r concat & find best}
  # Turn the list into a dataframe 
  HL_df<-as.data.frame(do.call(rbind, outcome_concat))
  HL_df<-as.data.frame(lapply(HL_df, as.numeric))
  
  # set some names
  colnames(HL_df)<-c("survival", "sd","th_row", "rep", paste((1:(ncol(HL_df)-4))))

  # order in order of performance 
  HL_df<-HL_df %>%
    group_by(th_row)%>%
    mutate(sum_survival=sum(survival))%>%
    ungroup()%>%
    arrange(desc(sum_survival))

  # Set wd for saving 
  save_wd<-(paste0(general_folder,"/output_subset", subset, "/level_", level, "/concat_results"))
  setwd(save_wd)
  
  # Save in the folder
  save(HL_df, file=paste0('out_concat_HPC_',  format(Sys.time(), "%Y-%m-%d_%H_%M_%S"),"__MOD_", model_type,'_lev', level, '.Rda'))
  
```

## Generate csv file for next level 
Take the specified best threshold and determine the new combinations that need to be ran in the next level. They are retrieved from the preset branches that I generated a while ago. Put these in a csv file that is saved for hte next level. Each row in this csv is a new threshold combination. 

This code can be running for each level. For level 1 it will just generate the first combinations. For level 2 and 3 it will generate the dataframe for the next level, based on the outcome of the preceding level. 

```{r make the new branch}
# Settings 
next_level<-(level+1)
next_level_chr<-paste0("level", next_level) # This specifies the level that you are creating the new dataframe for. 

# For when you are not runnin ghte first level  
if(next_level_chr=="level2"){
# Extract best values from previous level 
      # Set the wd to where the concatenation results are 
      setwd(paste0(general_folder, "/output_subset", subset, "/level_", level, "/concat_results"))
      # Load the relevant dataframe 
      filenames <- list.files(pattern=paste0("*MOD_", model_type, "_lev", level, ".Rda"), full.names=TRUE)
      load(filenames[1])
      # Extract first row 
      best_th<-HL_df[1,]
      # extract the thresholds 
      thresholds<-best_th[,5:(ncol(HL_df)-1)]
      best_comb_chr<-paste(thresholds, collapse=" & ")
}else if(next_level_chr=="level3"){
  # Best of level 1
      # Set the wd to where the concatenation results are 
      setwd(paste0(general_folder, "/output_subset", subset, "/level_", (level-1), "/concat_results"))
      # Load the relevant dataframe 
      filenames <- list.files(pattern=paste0("*MOD_", model_type, "_lev", (level-1), ".Rda"), full.names=TRUE)
      load(filenames[1])
      # Extract first row 
      best_th<-HL_df[1,]
      # extract the thresholds 
      thresholds<-best_th[,5:(ncol(HL_df)-1)]
      best_comb_chr_l1<-paste(thresholds, collapse=" & ")
  
  # For the best th from level 2
      # Set the wd to where the concatenation results are 
      setwd(paste0(general_folder, "/output_subset", subset, "/level_", level, "/concat_results"))
      # Load the relevant dataframe 
      filenames <- list.files(pattern=paste0("*MOD_", model_type, "_lev", level, ".Rda"), full.names=TRUE)
      load(filenames[1])
      # Extract first row 
      best_th<-HL_df[1,]
      # extract the thresholds 
      thresholds<-best_th[,5:(ncol(HL_df)-1)]
      best_comb_chr_l2<-paste(thresholds, collapse=" & ")
}



# Go into the folder that has the premade branches 
setwd(general_folder)
load(paste0("branch_sub", subset, "_x", (str_sub(model_type, 2, 2)), "_mod", model_type, ".Rda"))

# Then select what you want to do 

if(next_level_chr=="level1"){
  # Select the right part of the tree 
  selected_df<-tree_output_list[[next_level]]
  # save it
   write.table(selected_df, file=paste0('th_HPC_sub', subset, "_x",  (str_sub(model_type, 2,2)), "_mod", 
                                        model_type, '_level', next_level, '.csv'), row.names = F, col.names = F)
}else if(next_level_chr=="level2"){
  # Select the right part of the tree 
  selected_df<-tree_output_list[[next_level]][[paste(best_comb_chr)]]
    # save it 
   write.table(selected_df, file=paste0('th_HPC_sub', subset, "_x",  (str_sub(model_type, 2,2)), "_mod", 
                                        model_type, '_level', next_level, '.csv'), row.names = F, col.names = F)
}else if(level=="level3"){
    # Select the right part of the tree 
    selected_df<-tree_output_list[[next_level]][[paste(best_comb_chr_l1)]][[paste(best_comb_chr_l2)]]
    # save it
    write.table(selected_df, file=paste0('th_HPC_sub', subset, "_x",  (str_sub(model_type, 2,2)), "_mod", 
                                         model_type, '_level', next_level, '.csv'), row.names = F, col.names = F)
}


```


