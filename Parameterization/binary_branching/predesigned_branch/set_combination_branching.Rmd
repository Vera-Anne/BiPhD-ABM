---
title: "Making branches for each model"
author: "Vera Vinken"
date: "`r Sys.Date()`"
output: html_document
---
  
## Packages 

```{r packages, include=TRUE, message=FALSE, warning=FALSE}
library(dplyr)

library(stringr) # to select the 2nd digit of a number with the str_sub() function 

library(beepr) # beep when done 
```

## Background

## Set working directories 
```{r set working directories}
file_folder<-"C:/Users/c0070955/OneDrive - Newcastle University/1-PHD-project/Modelling/HPC/predesigned_branches"
setwd(file_folder)

```



## Functions for single -variable models 

```{r function for simple branching, include=TRUE, message=F, warning=F}

# Basic branching function 
    branch_func<-function(range_min, range_max, branch_num){
      
      # determine stepsize
      step_size<<-((range_max-range_min)/branch_num)
      
      if (branch_num==4){
        # Set the value for the threshold for each branch
        th_b1<-round(x=range_min + (step_size/2), digits = 5)
        th_b2<-round(x=th_b1+step_size, digits = 5)
        th_b3<-round(x=th_b2+step_size, digits = 5)
        th_b4<-round(x=th_b3+step_size, digits = 5)
        
        # concatenate output 
        output_branches<<-c(th_b1, th_b2, th_b3, th_b4, step_size)
      } else if(branch_num==6){
        print("branch num = 6")
        # Set the value for the threshold for each branch
          th_b1<-round(x=range_min + (step_size/2), digits = 5)
          th_b2<-round(x=th_b1+step_size, digits=5)
          th_b3<-round(x=th_b2+step_size, digits = 5)
          th_b4<-round(x=th_b3+step_size, digits = 5)
          th_b5<-round(x=th_b4+step_size, digits = 5)
          th_b6<-round(x=th_b5+step_size, digits = 5)
      
        # concatenate output 
        output_branches<<-c(th_b1, th_b2, th_b3, th_b4, th_b5, th_b6, step_size)
      } else if(branch_num==8){
        print("branch num = 8")
        # Set the value for the threshold for each branch
          th_b1<-round(x=range_min + (step_size/2), digits = 5)
          th_b2<-round(x=th_b1+step_size, digits=5)
          th_b3<-round(x=th_b2+step_size, digits = 5)
          th_b4<-round(x=th_b3+step_size, digits = 5)
          th_b5<-round(x=th_b4+step_size, digits = 5)
          th_b6<-round(x=th_b5+step_size, digits = 5)
          th_b7<-round(x=th_b6+step_size, digits = 5)
          th_b8<-round(x=th_b7+step_size, digits = 5)
      
        # concatenate output 
        output_branches<<-c(th_b1, th_b2, th_b3, th_b4, th_b5, th_b6, th_b7, th_b8, step_size)
      } else if (branch_num == 10){
        print("branch num = 10")
          th_b1<-round(x=range_min + (step_size/2), digits = 5)
          th_b2<-round(x=th_b1+step_size, digits=5)
          th_b3<-round(x=th_b2+step_size, digits = 5)
          th_b4<-round(x=th_b3+step_size, digits = 5)
          th_b5<-round(x=th_b4+step_size, digits = 5)
          th_b6<-round(x=th_b5+step_size, digits = 5)
          th_b7<-round(x=th_b6+step_size, digits = 5)
          th_b8<-round(x=th_b7+step_size, digits = 5)
          th_b9<-round(x=th_b8+step_size, digits = 5)
          th_b10<-round(x=th_b9+step_size, digits = 5)
          
        # concatenate output 
        output_branches<<-c(th_b1, th_b2, th_b3, th_b4, th_b5, th_b6, th_b7, th_b8, th_b9, th_b10, step_size)
      }else if (branch_num == 12){
          print("branch num = 12")
          th_b1<-round(x=range_min + (step_size/2), digits = 5)
          th_b2<-round(x=th_b1+step_size, digits=5)
          th_b3<-round(x=th_b2+step_size, digits = 5)
          th_b4<-round(x=th_b3+step_size, digits = 5)
          th_b5<-round(x=th_b4+step_size, digits = 5)
          th_b6<-round(x=th_b5+step_size, digits = 5)
          th_b7<-round(x=th_b6+step_size, digits = 5)
          th_b8<-round(x=th_b7+step_size, digits = 5)
          th_b9<-round(x=th_b8+step_size, digits = 5)
          th_b10<-round(x=th_b9+step_size, digits = 5)
          th_b11<-round(x=th_b10+step_size, digits = 5)
          th_b12<-round(x=th_b11+step_size, digits = 5)
          
        # concatenate output 
        output_branches<<-c(th_b1, th_b2, th_b3, th_b4, th_b5, th_b6, th_b7, th_b8, th_b9, th_b10, th_b11, th_b12, step_size)
        
      }
      
      # return branching output 
      return(output_branches)
    }

```


New tree-branching functions from 31/01/24
x.1 
```{r subset 1 tree branching functions}

tree_func_x1<-function(model_type, branch_num){
    # set original branch number
    branch_num_og<-branch_num
    # Branch_num sets the number of branches for the first level
    # level 2 and 3 always have branch_num = 4 
    
    # Set the starting values 
      if(model_type==11){
        start_min<-0
        start_max<-0.4
      }else if(model_type==21){
        start_min<-0
        start_max<-4
      }else if(model_type==31){
        start_min<-(-0.6)
        start_max<-0.6
      }else{print("there is a problem with model_type")}
      
      # Set the level depth 
      depth<-3
      
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch 
              out_th<-branch_func(range_min = start_min, range_max = start_max, branch_num = branch_num)
              
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(out_th[branch_num+1])

            # Add the output to the list 
              tree_output_list[[i]]<-as.data.frame(out_th[1:branch_num])
              
          }else if(i==2){
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4 
            
              for (j in 1:nrow(tree_output_list[[i-1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min<-(tree_output_list[[1]][[1]][[j]]-(0.5*stepsize_list[[1]][[1]]))

                  # calculate the new maximum 
                  cur_max<-(tree_output_list[[1]][[1]][[j]]+(0.5*stepsize_list[[1]][[1]]))
                  
                  # run the function 
                  out<-branch_func(range_min = cur_min, range_max = cur_max, branch_num = branch_num)
   
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(out[branch_num+1])
     
                  # Add the output to the list 
                  level_list[[j]]<-as.data.frame(out[1:branch_num])
                  
                  # Determine current name 
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]]))
                  
                  # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
                  
              } # end j-loop
            
            # Sort naming 
             names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j
            
          }else if(i==3){
            # For level 3 
            # Set the branch number back to 4 if needed 
            branch_num<-4 

            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum 
                      cur_min<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[2]][[j]][[1]]))

                      # calculate the new maximum 
                      cur_max<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[2]][[j]][[1]]))
                
                      # run the function 
                      out<-branch_func(range_min = cur_min, range_max = cur_max, branch_num = branch_num)
                  
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(out[branch_num+1])
      
                      # Add the output to the list 
                      list_new_th[[k]]<-as.data.frame(out[1:branch_num])
                      
                      # Determine current name
                      cur_name<-(paste(tree_output_list[[2]][[j]][[1]][[k]]))
                      # attach to vector 
                      if(k==1){
                        name_vector_k<-cur_name
                      }else{
                        name_vector_k<-c(name_vector_k, cur_name)
                      }
                  } # end of k-loop 
              
              # Add names 
              names(list_new_th)<-name_vector_k

              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
              stepsize_list_j[[j]]<-stepsize_list_k
              
              # Determine current name 
              cur_name<-(paste(tree_output_list[[1]][[1]][[j]]))
                  
              # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
            } # end of j-loop 
            
            # Sort names 
            names(level_list)<-name_vector_j
            
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
          }
        
      } # end the for loop 
   names(tree_output_list)<-c("level1", "level2", "level3")
   # save it 
    setwd(file_folder)
    print(branch_num_og)
    save(tree_output_list, file=paste0("branch", branch_num_og, "_sub1_x1_mod", model_type, ".Rda"))
   return(tree_output_list)
    
    # Beep when done 
    beep()
    print(paste("set branching tree for mod=", model_type , "and Branch number level 1 = ", branch_num_og))
} # End the function 
   
```

First run  x.1 models 

```{r run branching, include=TRUE, message=F, warning=F}
out_sub1_x1<-tree_func_x1(model_type = 31, branch_num = 10)
```
x.2 
```{r write sub1 x.2 models}
    
# Build a tree for the x.2 models (subset 1 - one variable)
tree_func_x2<-function(model_type, branch_num){
    # set original branch number
    branch_num_og<-branch_num
      if(model_type==12){
        start_min_th1<-0
        start_max_th1<-0.4
        start_min_th2<-0
        start_max_th2<-0.4
      }else if(model_type==22){
        start_min_th1<-0
        start_max_th1<-4
        start_min_th2<-0
        start_max_th2<-4
      }else if(model_type==32){
        start_min_th1<-(-0.6)
        start_max_th1<-0.6
        start_min_th2<-(-0.6)
        start_max_th2<-0.6
      }else{print("there is a problem with model_type")}
      
      depth<-3
      # Start the loop that will go through the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_th1<-branch_func(range_min = start_min_th1, range_max = start_max_th1, branch_num = branch_num)
              out_th2<-branch_func(range_min= start_min_th2, range_max = start_max_th2, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_th1[length(out_th1)], out_th2[length(out_th2)]))
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_th1[1:(length(out_th1)-1)], out_th2[1:(length(out_th2)-1)])
              colnames(grid)<-c("th1", "th2")
            # Subset this for cases where th2 > th 1 
              grid<-grid%>%
                filter(th1<th2)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
          }else if(i==2){
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4
            
              for (j in 1:nrow(tree_output_list[[i-1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_th1<-(tree_output_list[[i-1]][[1]][[j]]-(0.5*stepsize_list[[i-1]][[1]]))
                  cur_min_th2<-(tree_output_list[[i-1]][[2]][[j]]-(0.5*stepsize_list[[i-1]][[2]]))
                  # calculate the new maximum 
                  cur_max_th1<-(tree_output_list[[i-1]][[1]][[j]]+(0.5*stepsize_list[[i-1]][[1]]))
                  cur_max_th2<-(tree_output_list[[i-1]][[2]][[j]]+(0.5*stepsize_list[[i-1]][[2]]))
            
                  # run the function 
                  out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                  out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_th1[length(out_th1)], out_th2[length(out_th2)]))
      
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid((out_th1[1:(length(out_th1)-1)]), (out_th2[1:(length(out_th2)-1)]))
                  colnames(grid)<-c("th1", "th2")
                  # Subset this for cases where th2 > th 1 
                  grid<-grid%>%
                    filter(th1<th2)
                  
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  # Set up naming
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", tree_output_list[[1]][[2]][[j]]))
                  # attach to vector 
                      if(j==1){
                        name_vector_j<-cur_name
                      }else{
                        name_vector_j<-c(name_vector_j, cur_name)
                      }
              } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j

            
          }else if(i==3){
            # For level 3 
            # Set the branch number back to 4 if needed 
            branch_num<-4
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The default here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[2]][[j]][[1]]))
                      cur_min_th2<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[2]][[j]][[2]]))
                      # calculate the new maximum 
                      cur_max_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[2]][[j]][[1]]))
                      cur_max_th2<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[2]][[j]][[2]]))
                
                      # run the function 
                      out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                      out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(cbind(out_th1[length(out_th1)], out_th2[length(out_th2)]))
      
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_th1[1:(length(out_th1)-1)], out_th2[1:(length(out_th2)-1)])
                      colnames(grid)<-c("th1", "th2")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                        filter(th1<th2)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                      
                      # do something about the  names 
                      cur_name<-(paste(tree_output_list[[2]][[j]][[1]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[2]][[k]]))
                  # attach to vector 
                  if(k==1){
                    name_vector_k<-cur_name
                  }else{
                    name_vector_k<-c(name_vector_k, cur_name)
                  }
                      
                  } # end k-loop 
              
              # names 
              names(list_new_th)<-name_vector_k
              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
              stepsize_list_j[[j]]<-stepsize_list_k
              # Names for j-level 
              cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", tree_output_list[[1]][[2]][[j]]))
              # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
            } # end J-loop 
                # sort naming 
                names(level_list)<-name_vector_j
                # add to the tree outcome
                tree_output_list[[i]]<-level_list
                stepsize_list[[i]]<-stepsize_list_j
              
              } # level 3 end 
            
      } # end the for loop 
    
      # Fix names 
      names(tree_output_list)<-c("level1", "level2", "level3")
      # save it 
      setwd(file_folder)
      save(tree_output_list, file=paste0("branch", branch_num_og, "_sub1_x2_mod", model_type, ".Rda"))
      # Return to global 
      return(tree_output_list)
    
} # End the function 

```   


Run subset 1 x.2 models 

```{r run branching subset 1 x.2, include=TRUE, message=F, warning=F}
out_sub1_x2<-tree_func_x2(model_type = 32, branch_num = 10)
```

x.3
```{r build subset 1 x.3 models }
tree_func_x3<-function(model_type, branch_num){
    # set original branch number
    branch_num_og<-branch_num
       if((model_type==131)|(model_type==132)){
        start_min_th1<-0
        start_max_th1<-0.4
        start_min_th2<-0
        start_max_th2<-0.4
        start_min_th3<-0
        start_max_th3<-0.4
      }else if(model_type==231 | model_type==232){
        start_min_th1<-0
        start_max_th1<-4
        start_min_th2<-0
        start_max_th2<-4
        start_min_th3<-0
        start_max_th3<-4
      }else if(model_type==331 | model_type==332){
        start_min_th1<-(-0.6)
        start_max_th1<-0.6
        start_min_th2<-(-0.6)
        start_max_th2<-0.6
        start_min_th3<-(-0.6)
        start_max_th3<-0.6
      }else{print("there is a problem with model_type")}
      # set the hardcoded depth 
      depth<-3
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){

            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_th1<-branch_func(range_min = start_min_th1, range_max = start_max_th1, branch_num = branch_num)
              out_th2<-branch_func(range_min= start_min_th2, range_max = start_max_th2, branch_num = branch_num)
              out_th3<-branch_func(range_min= start_min_th3, range_max = start_max_th3, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_th1[branch_num+1], out_th2[branch_num+1], out_th3[branch_num+1]))
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_th1[1:branch_num], out_th2[1:branch_num], out_th3[1:branch_num])
              colnames(grid)<-c("th1", "th2", "th3")
            # Subset this for cases where th2 > th 1 
              grid<-grid%>%
                filter(th1<th2 & th2<th3)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
          }else if(i==2){
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_th1<-(tree_output_list[[i-1]][[1]][[j]]-(0.5*stepsize_list[[1]][[1]]))
                  cur_min_th2<-(tree_output_list[[i-1]][[2]][[j]]-(0.5*stepsize_list[[1]][[2]]))
                  cur_min_th3<-(tree_output_list[[i-1]][[3]][[j]]-(0.5*stepsize_list[[1]][[3]]))
                  # calculate the new maximum 
                  cur_max_th1<-(tree_output_list[[i-1]][[1]][[j]]+(0.5*stepsize_list[[1]][[1]]))
                  cur_max_th2<-(tree_output_list[[i-1]][[2]][[j]]+(0.5*stepsize_list[[1]][[2]]))
                  cur_max_th3<-(tree_output_list[[i-1]][[3]][[j]]+(0.5*stepsize_list[[1]][[3]]))
                  # run the function 
                  out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                  out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                  out_th3<-branch_func(range_min = cur_min_th3, range_max = cur_max_th3, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_th1[branch_num+1], out_th2[branch_num+1], out_th3[branch_num+1]))
      
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_th1[1:branch_num], out_th2[1:branch_num], out_th3[1:branch_num])
                  colnames(grid)<-c("th1", "th2", "th3")
                  # Subset this for cases where th2 > th 1 
                  grid<-grid%>%
                    filter(th1<th2 & th2<th3)
          
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  # Set up naming
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", tree_output_list[[1]][[2]][[j]], "&", tree_output_list[[1]][[3]][[j]]))
                  # attach to vector 
                      if(j==1){
                        name_vector_j<-cur_name
                      }else{
                        name_vector_j<-c(name_vector_j, cur_name)
                      }
              } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j

          }else if(i==3){
            # For level 3 
            # Set the branch number back to 4 if needed 
            branch_num<-4
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The default here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[2]][[j]][[1]]))
                      cur_min_th2<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[2]][[j]][[2]]))
                      cur_min_th3<-(tree_output_list[[2]][[j]][[3]][[k]]-(0.5*stepsize_list[[2]][[j]][[3]]))
                      # calculate the new maximum 
                      cur_max_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[2]][[j]][[1]]))
                      cur_max_th2<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[2]][[j]][[2]]))
                      cur_max_th3<-(tree_output_list[[2]][[j]][[3]][[k]]+(0.5*stepsize_list[[2]][[j]][[3]]))
                      # run the function 
                      out_th1<-branch_func(range_min = cur_min_th1, range_max = cur_max_th1, branch_num = branch_num)
                      out_th2<-branch_func(range_min = cur_min_th2, range_max = cur_max_th2, branch_num = branch_num)
                      out_th3<-branch_func(range_min = cur_min_th3, range_max = cur_max_th3, branch_num = branch_num)
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(cbind(out_th1[branch_num+1], out_th2[branch_num+1], out_th3[branch_num+1]))
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_th1[1:branch_num], out_th2[1:branch_num], out_th3[1:branch_num])
                      colnames(grid)<-c("th1", "th2", "th3")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                        filter(th1<th2 & th2<th3)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                      # do something about the  names 
                      cur_name<-(paste(tree_output_list[[2]][[j]][[1]][[k]], "&", tree_output_list[[2]][[j]][[2]][[k]], "&", tree_output_list[[2]][[j]][[3]][[k]]))
                  # attach to vector 
                  if(k==1){
                    name_vector_k<-cur_name
                  }else{
                    name_vector_k<-c(name_vector_k, cur_name)
                  }
                  } # end k-loop 
              
                  # names 
                  names(list_new_th)<-name_vector_k
                  
                   
            # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
              stepsize_list_j[[j]]<-stepsize_list_k

            # Set up naming
              cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", tree_output_list[[1]][[2]][[j]], "&", tree_output_list[[1]][[3]][[j]]))
            # attach to vector 
                if(j==1){
                        name_vector_j<-cur_name
                }else{
                        name_vector_j<-c(name_vector_j, cur_name)
                      }
            } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j

          } # end of level 3 
        
      } # end the for loop 
      
    # fix the names 
      names(tree_output_list)<-c("level1", "level2", "level3")
   # save it 
    setwd(file_folder)
    save(tree_output_list, file=paste0("branch", branch_num_og, "_sub1_x3_mod", model_type, ".Rda"))
   return(tree_output_list)
} # End the function 
```

Run the subset 1 x.3 models

```{r run branching subset 1 x.2, include=TRUE, message=F, warning=F}
out_sub1_x3<-tree_func_x3(model_type = 331, branch_num = 8)
```

## January 2024: 
I re-wrote the x.1, x.2 and x.3 fucntions for subset 1. They are outlined above. 

Then, I worked on the second subset of models: they have 2 variables that decisions are based on. 

Start with the simplest model: a non-hoarding bird, access to 2 variables, each with 1 threshold. 
The v's in the code stand for 'variable' (e.g. stmac content), the 'th' in the code are for 'threshold number'. So for example, a model with both SC and FR, each with 3 thresholds would have v1 (SC) and v3 (FR). For each of those there would be a th1, th2 and th3. 

```{r make subset 2 x.1 models}
# Non hoarder 2 variables 
    tree_func_sub2_x1<-function(model_type, branch_num){
      # set original branch number
      branch_num_og<-branch_num
      # settings 
      if(model_type==41){
        start_min_v1_th1<-0
        start_max_v1_th1<-4
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-(0.6)
      }else if(model_type==51){
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v2_th1<-0
        start_max_v2_th1<-4
      }else if(model_type==61){
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-(0.6)
      }
      depth<-3
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_v1_th1<-branch_func(range_min = start_min_v1_th1, range_max = start_max_v1_th1, branch_num = branch_num)
              out_v2_th1<-branch_func(range_min= start_min_v2_th1, range_max = start_max_v2_th1, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], out_v2_th1[branch_num+1]))
              colnames(stepsize_list[[i]])<-c("step_v1_th1", "step_v2_th1")
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_v1_th1[1:branch_num], out_v2_th1[1:branch_num])
              colnames(grid)<-c("v1_th1", "v2_th1")
            # Subset this for cases where th2 > th 1 
                  grid<-grid%>%
                    filter(case_when(
                      model_type=="41"~v1_th1>0, 
                      model_type=="51"~v1_th1>0 & v2_th1>0,
                      model_type=="61"~v1_th1>0
                    ))
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
              
          }else if(i==2){
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_v1_th1<-(tree_output_list[[i-1]][[1]][[j]]-(0.5*stepsize_list[[1]][[1]]))
                  cur_min_v2_th1<-(tree_output_list[[i-1]][[2]][[j]]-(0.5*stepsize_list[[1]][[2]]))
                  # calculate the new maximum 
                  cur_max_v1_th1<-(tree_output_list[[i-1]][[1]][[j]]+(0.5*stepsize_list[[1]][[1]]))
                  cur_max_v2_th1<-(tree_output_list[[i-1]][[2]][[j]]+(0.5*stepsize_list[[1]][[2]]))
                  # run the function 
                  out_v1_th1<-branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)
                  out_v2_th1<-branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], out_v2_th1[branch_num+1]))
                  colnames(stepsize_list_j[[j]])<-c("step_v1_th1", "step_v2_th1")
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_v1_th1[1:branch_num], out_v2_th1[1:branch_num])
                  colnames(grid)<-c("v1_th1", "v2_th1")
                  # In the cases of stoamch content and FR variables, this value cannot drop below 0. 
                  grid<-grid%>%
                    filter(case_when(
                      model_type=="41"~v1_th1>0, 
                      model_type=="51"~v1_th1>0 & v2_th1>0,
                      model_type=="61"~v1_th1>0
                    ))
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  # Set up naming
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", tree_output_list[[1]][[2]][[j]]))
                  # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
              } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j
            
          }else if(i==3){
            # For level 3 
            # Set the branch number back to 4 if needed 
            branch_num<-4
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_v1_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[2]][[j]][[1]]))
                      cur_min_v2_th1<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[2]][[j]][[2]]))
                      # calculate the new maximum 
                      cur_max_v1_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[2]][[j]][[1]]))
                      cur_max_v2_th1<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[2]][[j]][[2]]))
                      # run the function 
                      out_v1_th1<-branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)
                      out_v2_th1<-branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(cbind(out_v1_th1[branch_num+1],out_v2_th1[branch_num+1]))
                      colnames(stepsize_list_k[[k]])<-c("step_v1_th1", "step_v2_th1")
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_v1_th1[1:branch_num],out_v2_th1[1:branch_num])
                      colnames(grid)<-c("v1_th1", "v2_th1")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                        filter(case_when(
                          model_type=="41"~v1_th1>0, 
                          model_type=="51"~v1_th1>0 & v2_th1>0,
                          model_type=="61"~v1_th1>0
                      ))
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                      
                      # do something about the  names 
                      cur_name<-(paste(tree_output_list[[2]][[j]][[1]][[k]], "&",tree_output_list[[2]][[j]][[2]][[k]]))
                      
                      # attach to vector 
                      if(k==1){
                        name_vector_k<-cur_name
                      }else{
                        name_vector_k<-c(name_vector_k, cur_name)
                      }
                  } # end of k loop 
                  
                  # names 
                  names(list_new_th)<-name_vector_k
                  # Add the list with thresholds to the level list
                  level_list[[j]]<-list_new_th
                  # do something about the  names 
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", 
                                  tree_output_list[[1]][[2]][[j]]))
              # attach to vector 
              if(j==1){
                    name_vector_j2<-cur_name
                  }else{
                    name_vector_j2<-c(name_vector_j2, cur_name)
                  }
            } # end j loop 
            # sort the names 
            names(level_list)<-name_vector_j2
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
          } # end i==3 
        
      } # end the for loop 
    names(tree_output_list)<-c("level1", "level2", "level3")
    # save it 
    setwd(file_folder)
    save(tree_output_list, file=paste0("branch", branch_num_og, "_sub2_x1_mod", model_type, ".Rda"))
    return(tree_output_list)
} # End the function 
```

Run the non-hoarding, 2 variables, 1 th model: 
```{r run subset 2 x1}
out_sub2_x1<-tree_func_sub2_x1(model_type=61, branch_num = 10)
```

Now, write teh code for the second subset, the leftover hoarders. This has 2 energy proxy variables and each of these has 2 thresholds. 
```{r make subset 2 x.2 models}
# Non hoarder 2 variables 
    tree_func_sub2_x2<-function(model_type, branch_num){
      # set original branch number
      branch_num_og<-branch_num
      # settings 
      if(model_type==42){
        
        # variable 1 = FR
        start_min_v1_th1<-0
        start_max_v1_th1<-4
        start_min_v1_th2<-0
        start_max_v1_th2<-4
        # variable 2 = FLR
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-0.6
        start_min_v2_th2<-(-0.6)
        start_max_v2_th2<-0.6
        
      }else if(model_type==52){
        # variable 1 = SC
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v1_th2<-0
        start_max_v1_th2<-0.4
        # variable 2 = FR
        start_min_v2_th1<-0
        start_max_v2_th1<-4
        start_min_v2_th2<-0
        start_max_v2_th2<-4
      }else if(model_type==62){
        # variable 1 = SC
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v1_th2<-0
        start_max_v1_th2<-0.4
        # variable 2 = FLR
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-0.6
        start_min_v2_th2<-(-0.6)
        start_max_v2_th2<-0.6
      }else{print("There is a problem with the modeltype ")}
      # set depth (hardcoded now)
      depth<-3
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){
            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_v1_th1<-branch_func(range_min = start_min_v1_th1, range_max = start_max_v1_th1, branch_num = branch_num)
              out_v2_th1<-branch_func(range_min= start_min_v2_th1, range_max = start_max_v2_th1, branch_num = branch_num)
              out_v1_th2<-branch_func(range_min = start_min_v1_th2, range_max = start_max_v1_th2, branch_num = branch_num)
              out_v2_th2<-branch_func(range_min= start_min_v2_th2, range_max = start_max_v2_th2, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                      out_v2_th1[branch_num+1], 
                                                      out_v1_th2[branch_num+1], 
                                                      out_v2_th2[branch_num+1]))
              colnames(stepsize_list[[i]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2")
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_v1_th1[1:branch_num], 
                                out_v2_th1[1:branch_num], 
                                out_v1_th2[1:branch_num], 
                                out_v2_th2[1:branch_num])
              colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2")
            # Subset this for cases 
              grid<-grid%>%
                  filter(case_when( model_type=="42"~v1_th1>0 & v1_th2>0, 
                                    model_type=="52"~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0,
                                    model_type=="62"~v1_th1>0 & v1_th2>0))%>%
                  filter(v1_th1<v1_th2)%>%
                  filter(v2_th1<v2_th2)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
              
          }else if(i==2){
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_v1_th1<-(tree_output_list[[1]][[1]][[j]]-(0.5*stepsize_list[[1]][[1]]))
                  cur_min_v2_th1<-(tree_output_list[[1]][[2]][[j]]-(0.5*stepsize_list[[1]][[2]]))
                  cur_min_v1_th2<-(tree_output_list[[1]][[3]][[j]]-(0.5*stepsize_list[[1]][[3]]))
                  cur_min_v2_th2<-(tree_output_list[[1]][[4]][[j]]-(0.5*stepsize_list[[1]][[4]]))
                  # calculate the new maximum 
                  cur_max_v1_th1<-(tree_output_list[[1]][[1]][[j]]+(0.5*stepsize_list[[1]][[1]]))
                  cur_max_v2_th1<-(tree_output_list[[1]][[2]][[j]]+(0.5*stepsize_list[[1]][[2]]))
                  cur_max_v1_th2<-(tree_output_list[[1]][[3]][[j]]+(0.5*stepsize_list[[1]][[3]]))
                  cur_max_v2_th2<-(tree_output_list[[1]][[4]][[j]]+(0.5*stepsize_list[[1]][[4]]))
                  # run the function 
                  out_v1_th1<-branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)
                  out_v2_th1<-branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)
                  out_v1_th2<-branch_func(range_min = cur_min_v1_th2, range_max = cur_max_v1_th2, branch_num = branch_num)
                  out_v2_th2<-branch_func(range_min = cur_min_v2_th2, range_max = cur_max_v2_th2, branch_num = branch_num)
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                            out_v2_th1[branch_num+1], 
                                                            out_v1_th2[branch_num+1], 
                                                            out_v2_th2[branch_num+1]))
                  colnames(stepsize_list_j[[j]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2")
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_v1_th1[1:branch_num], 
                                    out_v2_th1[1:branch_num], 
                                    out_v1_th2[1:branch_num], 
                                    out_v2_th2[1:branch_num])
                  colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2")
                  # Subset this for cases where th2 > th 1 
                  grid<-grid%>%
                              filter(case_when( model_type=="42"~v1_th1>0 & v1_th2>0, 
                                                model_type=="52"~v1_th1>0 & v2_th1>0 &v1_th2>0 & v2_th2>0,
                                                model_type=="62"~v1_th1>0 & v1_th2>0))%>%
                              filter(v1_th1<v1_th2)%>%
                              filter(v2_th1<v2_th2)
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  #names(level_list[[j]])<-c("test5")
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", 
                                   tree_output_list[[1]][[2]][[j]], "&", 
                                   tree_output_list[[1]][[3]][[j]], "&", 
                                   tree_output_list[[1]][[4]][[j]]))
                  # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
              } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j
            
          }else if(i==3){
            # For level 3 
            # Set the branch number back to 4 if needed 
            branch_num<-4
            for (j in 1:length(tree_output_list[[2]])){
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_v1_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[1]]))
                      cur_min_v2_th1<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[2]]))
                      cur_min_v1_th2<-(tree_output_list[[2]][[j]][[3]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[3]]))
                      cur_min_v2_th2<-(tree_output_list[[2]][[j]][[4]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[4]]))
                      # calculate the new maximum 
                      cur_max_v1_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[1]]))
                      cur_max_v2_th1<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[2]]))
                      cur_max_v1_th2<-(tree_output_list[[2]][[j]][[3]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[3]]))
                      cur_max_v2_th2<-(tree_output_list[[2]][[j]][[4]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[4]]))
                      # run the function 
                      out_v1_th1<-t(as.data.frame(branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)))
                      out_v2_th1<-t(as.data.frame(branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)))
                      out_v1_th2<-t(as.data.frame(branch_func(range_min = cur_min_v1_th2, range_max = cur_max_v1_th2, branch_num = branch_num)))
                      out_v2_th2<-t(as.data.frame(branch_func(range_min = cur_min_v2_th2, range_max = cur_max_v2_th2, branch_num = branch_num)))
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                                out_v2_th1[branch_num+1], 
                                                                out_v1_th2[branch_num+1], 
                                                                out_v2_th2[branch_num+1]))
                      colnames(stepsize_list_k[[k]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2")
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_v1_th1[1:branch_num], 
                                        out_v2_th1[1:branch_num], 
                                        out_v1_th2[1:branch_num], 
                                        out_v2_th2[1:branch_num])
                      colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2")
                      #grid<-as.numeric(grid)
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                          filter(case_when( model_type=="42"~v1_th1>0 & v1_th2>0, 
                                            model_type=="52"~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0,
                                            model_type=="62"~v1_th1>0 & v1_th2>0))%>%
                          filter(v1_th1<v1_th2)%>%
                          filter(v2_th1<v2_th2)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                      # do something about the  names 
                      cur_name<-(paste(tree_output_list[[2]][[j]][[1]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[2]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[3]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[4]][[k]]))
                  # attach to vector 
                  if(k==1){
                    name_vector_k<-cur_name
                  }else{
                    name_vector_k<-c(name_vector_k, cur_name)
                  }
                } # end of k loop 
                  
                  # names 
                  names(list_new_th)<-name_vector_k
              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
              # do something about the  names 
              cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", 
                                   tree_output_list[[1]][[2]][[j]], "&", 
                                   tree_output_list[[1]][[3]][[j]], "&", 
                                   tree_output_list[[1]][[4]][[j]]))
              # attach to vector 
              if(j==1){
                    name_vector_j2<-cur_name
                  }else{
                    name_vector_j2<-c(name_vector_j2, cur_name)
                  }
            } # end j loop 
            # sort the names 
            names(level_list)<-name_vector_j2
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
          }
        
      } # end the for loop 
   names(tree_output_list)<-c("level1", "level2", "level3")
  # save it 
    setwd(file_folder)
    save(tree_output_list, file=paste0("branch", branch_num_og, "_sub2_x2_mod", model_type, ".Rda"))
   return(tree_output_list)
} # End the function 
```

Subset 2 - x.2
Run the leftover hoarding, 2 variables, 2 th model: 
```{r run subset 2 x2}

out_sub2_x2<-tree_func_sub2_x2(model_type=42, branch_num = 10)

```

Subset 2 - x.3
Now, write hte function for the 2nd subset, direct hoarders with 2 variables and 3 thresholds each. 

```{r make subset 2 x.3 models}

# Non hoarder 2 variables 
    tree_func_sub2_x3<-function(model_type, branch_num){
            # Log the original branch number
            branch_num_og<-branch_num
      
      if((model_type==431)|(model_type==432)){

        # variable 1 = FR
        start_min_v1_th1<-0
        start_max_v1_th1<-4
        start_min_v1_th2<-0
        start_max_v1_th2<-4
        start_min_v1_th3<-0
        start_max_v1_th3<-4
        # variable 2 = FLR
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-0.6
        start_min_v2_th2<-(-0.6)
        start_max_v2_th2<-0.6
        start_min_v2_th3<-(-0.6)
        start_max_v2_th3<-0.6
      }else if(model_type==531|model_type==532){
        # variable 1 = SC
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v1_th2<-0
        start_max_v1_th2<-0.4
        start_min_v1_th3<-0
        start_max_v1_th3<-0.4
        # variable 2 = FR
        start_min_v2_th1<-0
        start_max_v2_th1<-4
        start_min_v2_th2<-0
        start_max_v2_th2<-4
        start_min_v2_th3<-0
        start_max_v2_th3<-4
      }else if(model_type==631|model_type==632){
        # variable 1 = SC
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v1_th2<-0
        start_max_v1_th2<-0.4
        start_min_v1_th3<-0
        start_max_v1_th3<-0.4
        # variable 2 = FLR
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-0.6
        start_min_v2_th2<-(-0.6)
        start_max_v2_th2<-0.6
        start_min_v2_th3<-(-0.6)
        start_max_v2_th3<-0.6
      }else{print("something is wrong with the model_type setting")}
      depth<-3
      # Start the loop that will go thrugh the number of steps as set in 'depth' 
      for (i in 1:depth){
        # Generate a list for the output 
          if (i==1){

            # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
            # Run the function to branch for the first th 
              out_v1_th1<-branch_func(range_min = start_min_v1_th1, range_max = start_max_v1_th1, branch_num = branch_num)
              out_v2_th1<-branch_func(range_min= start_min_v2_th1, range_max = start_max_v2_th1, branch_num = branch_num)
              out_v1_th2<-branch_func(range_min = start_min_v1_th2, range_max = start_max_v1_th2, branch_num = branch_num)
              out_v2_th2<-branch_func(range_min= start_min_v2_th2, range_max = start_max_v2_th2, branch_num = branch_num)
              out_v1_th3<-branch_func(range_min = start_min_v1_th3, range_max = start_max_v1_th3, branch_num = branch_num)
              out_v2_th3<-branch_func(range_min= start_min_v2_th3, range_max = start_max_v2_th3, branch_num = branch_num)
            # Extract the stepsize 
              stepsize_list[[i]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                      out_v2_th1[branch_num+1], 
                                                      out_v1_th2[branch_num+1], 
                                                      out_v2_th2[branch_num+1], 
                                                      out_v1_th3[branch_num+1], 
                                                      out_v2_th3[branch_num+1]))
              colnames(stepsize_list[[i]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2", "step_v1_th3", "step_v2_th3")
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_v1_th1[1:branch_num], 
                                out_v2_th1[1:branch_num], 
                                out_v1_th2[1:branch_num], 
                                out_v2_th2[1:branch_num], 
                                out_v1_th3[1:branch_num], 
                                out_v2_th3[1:branch_num])
              colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2", "v1_th3", "v2_th3")
            # Subset this for cases 
                  grid<-grid%>%
                    filter(case_when( ((model_type=="431")|(model_type=="432"))~v1_th1>0 & v1_th2>0 & v1_th3>0, 
                                      ((model_type=="531")|(model_type=="532"))~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0 & v1_th3>0 & v2_th3>0,
                                      ((model_type=="631")|(model_type=="632"))~v1_th1>0 & v1_th2>0 & v1_th3>0))%>%
                    filter(v1_th1<v1_th2)%>%
                    filter(v2_th1<v2_th2)%>%
                    filter(v1_th2<v1_th3)%>%
                    filter(v2_th2<v2_th3)
            # Add the output to the list 
              tree_output_list[[i]]<-grid
            # print
              print("i=1 done")
              
          }else if(i==2){
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                
                  # Calculate the new minimum for th1 
                  cur_min_v1_th1<-(tree_output_list[[1]][[1]][[j]]-(0.5*stepsize_list[[1]][[1]]))
                  cur_min_v2_th1<-(tree_output_list[[1]][[2]][[j]]-(0.5*stepsize_list[[1]][[2]]))
                  cur_min_v1_th2<-(tree_output_list[[1]][[3]][[j]]-(0.5*stepsize_list[[1]][[3]]))
                  cur_min_v2_th2<-(tree_output_list[[1]][[4]][[j]]-(0.5*stepsize_list[[1]][[4]]))
                  cur_min_v1_th3<-(tree_output_list[[1]][[5]][[j]]-(0.5*stepsize_list[[1]][[5]]))
                  cur_min_v2_th3<-(tree_output_list[[1]][[6]][[j]]-(0.5*stepsize_list[[1]][[6]]))
                  # calculate the new maximum 
                  cur_max_v1_th1<-(tree_output_list[[1]][[1]][[j]]+(0.5*stepsize_list[[1]][[1]]))
                  cur_max_v2_th1<-(tree_output_list[[1]][[2]][[j]]+(0.5*stepsize_list[[1]][[2]]))
                  cur_max_v1_th2<-(tree_output_list[[1]][[3]][[j]]+(0.5*stepsize_list[[1]][[3]]))
                  cur_max_v2_th2<-(tree_output_list[[1]][[4]][[j]]+(0.5*stepsize_list[[1]][[4]]))
                  cur_max_v1_th3<-(tree_output_list[[1]][[5]][[j]]+(0.5*stepsize_list[[1]][[5]]))
                  cur_max_v2_th3<-(tree_output_list[[1]][[6]][[j]]+(0.5*stepsize_list[[1]][[6]]))
                  # run the function 
                  out_v1_th1<-branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)
                  out_v2_th1<-branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)
                  out_v1_th2<-branch_func(range_min = cur_min_v1_th2, range_max = cur_max_v1_th2, branch_num = branch_num)
                  out_v2_th2<-branch_func(range_min = cur_min_v2_th2, range_max = cur_max_v2_th2, branch_num = branch_num)
                  out_v1_th3<-branch_func(range_min = cur_min_v1_th3, range_max = cur_max_v1_th3, branch_num = branch_num)
                  out_v2_th3<-branch_func(range_min = cur_min_v2_th3, range_max = cur_max_v2_th3, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                            out_v2_th1[branch_num+1], 
                                                            out_v1_th2[branch_num+1], 
                                                            out_v2_th2[branch_num+1], 
                                                            out_v1_th3[branch_num+1], 
                                                            out_v2_th3[branch_num+1] 
                                                            ))
                  colnames(stepsize_list_j[[j]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2", "step_v1_th3", "step_v2_th3")
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_v1_th1[1:branch_num], 
                                    out_v2_th1[1:branch_num], 
                                    out_v1_th2[1:branch_num], 
                                    out_v2_th2[1:branch_num], 
                                    out_v1_th3[1:branch_num], 
                                    out_v2_th3[1:branch_num])
                  # colnames 
                  colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2", "v1_th3", "v2_th3")
                  # Subset this for cases where th2 > th 1 
                          grid<-grid%>%
                    filter(case_when( ((model_type=="431")|(model_type=="432"))~v1_th1>0 & v1_th2>0 & v1_th3>0, 
                                      ((model_type=="531")|(model_type=="532"))~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0 & v1_th3>0 & v2_th3>0,
                                      ((model_type=="631")|(model_type=="632"))~v1_th1>0 & v1_th2>0 & v1_th3>0))%>%
                    filter(v1_th1<v1_th2)%>%
                    filter(v2_th1<v2_th2)%>%
                    filter(v1_th2<v1_th3)%>%
                    filter(v2_th2<v2_th3)
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  #names(level_list[[j]])<-c("test5")
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", 
                                   tree_output_list[[1]][[2]][[j]], "&", 
                                   tree_output_list[[1]][[3]][[j]], "&", 
                                   tree_output_list[[1]][[4]][[j]], "&", 
                                   tree_output_list[[1]][[5]][[j]], "&", 
                                   tree_output_list[[1]][[6]][[j]]))
                  # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
              } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            stepsize_list[[i]]<-stepsize_list_j
            # print
            print("i=2 done")
            print(paste("the number of j's that need doing is= ", length(tree_output_list[[2]])))
            
          }else if(i==3){
            # For level 3 
            # Set the branch number back to 4 if needed 
            branch_num<-4
            for (j in 1:length(tree_output_list[[2]])){
              
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The defualt here would be 16 
                  for (k in 1:nrow(tree_output_list[[2]][[j]])){
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_v1_th1<-(tree_output_list[[2]][[j]][[1]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[1]]))
                      cur_min_v2_th1<-(tree_output_list[[2]][[j]][[2]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[2]]))
                      cur_min_v1_th2<-(tree_output_list[[2]][[j]][[3]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[3]]))
                      cur_min_v2_th2<-(tree_output_list[[2]][[j]][[4]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[4]]))
                      cur_min_v1_th3<-(tree_output_list[[2]][[j]][[5]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[5]]))
                      cur_min_v2_th3<-(tree_output_list[[2]][[j]][[6]][[k]]-(0.5*stepsize_list[[i-1]][[j]][[6]]))
                      # calculate the new maximum 
                      cur_max_v1_th1<-(tree_output_list[[2]][[j]][[1]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[1]]))
                      cur_max_v2_th1<-(tree_output_list[[2]][[j]][[2]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[2]]))
                      cur_max_v1_th2<-(tree_output_list[[2]][[j]][[3]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[3]]))
                      cur_max_v2_th2<-(tree_output_list[[2]][[j]][[4]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[4]]))
                      cur_max_v1_th3<-(tree_output_list[[2]][[j]][[5]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[5]]))
                      cur_max_v2_th3<-(tree_output_list[[2]][[j]][[6]][[k]]+(0.5*stepsize_list[[i-1]][[j]][[6]]))
                      # run the function 
                      out_v1_th1<-t(as.data.frame(branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)))
                      out_v2_th1<-t(as.data.frame(branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)))
                      out_v1_th2<-t(as.data.frame(branch_func(range_min = cur_min_v1_th2, range_max = cur_max_v1_th2, branch_num = branch_num)))
                      out_v2_th2<-t(as.data.frame(branch_func(range_min = cur_min_v2_th2, range_max = cur_max_v2_th2, branch_num = branch_num)))
                      out_v1_th3<-t(as.data.frame(branch_func(range_min = cur_min_v1_th3, range_max = cur_max_v1_th3, branch_num = branch_num)))
                      out_v2_th3<-t(as.data.frame(branch_func(range_min = cur_min_v2_th3, range_max = cur_max_v2_th3, branch_num = branch_num)))
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                                out_v2_th1[branch_num+1], 
                                                                out_v1_th2[branch_num+1], 
                                                                out_v2_th2[branch_num+1], 
                                                                out_v1_th3[branch_num+1], 
                                                                out_v2_th3[branch_num+1]))
                      colnames(stepsize_list_k[[k]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2", "step_v1_th3", "step_v2_th3")
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_v1_th1[1:branch_num], 
                                        out_v2_th1[1:branch_num], 
                                        out_v1_th2[1:branch_num], 
                                        out_v2_th2[1:branch_num], 
                                        out_v1_th3[1:branch_num], 
                                        out_v2_th3[1:branch_num])
                      colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2", "v1_th3", "v2_th3")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                    filter(case_when( ((model_type=="431")|(model_type=="432"))~v1_th1>0 & v1_th2>0 & v1_th3>0, 
                                      ((model_type=="531")|(model_type=="532"))~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0 & v1_th3>0 & v2_th3>0,
                                      ((model_type=="631")|(model_type=="632"))~v1_th1>0 & v1_th2>0 & v1_th3>0))%>%
                    filter(v1_th1<v1_th2)%>%
                    filter(v2_th1<v2_th2)%>%
                    filter(v1_th2<v1_th3)%>%
                    filter(v2_th2<v2_th3)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                      # do something about the  names 
                      cur_name<-(paste(tree_output_list[[2]][[j]][[1]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[2]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[3]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[4]][[k]], "&", 
                                   tree_output_list[[2]][[j]][[5]][[k]], "&",
                                   tree_output_list[[2]][[j]][[6]][[k]]))
                  # attach to vector 
                  if(k==1){
                    name_vector_k<-cur_name
                  }else{
                    name_vector_k<-c(name_vector_k, cur_name)
                  }
                } # end of k loop 
                  # names 
                  names(list_new_th)<-name_vector_k

              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
              # do something about the  names 
              cur_name<-(paste(    tree_output_list[[1]][[1]][[j]], "&", 
                                   tree_output_list[[1]][[2]][[j]], "&", 
                                   tree_output_list[[1]][[3]][[j]], "&", 
                                   tree_output_list[[1]][[4]][[j]], "&", 
                                   tree_output_list[[1]][[5]][[j]], "&",
                                   tree_output_list[[1]][[6]][[j]], "&"))
              # attach to vector 
              if(j==1){
                    name_vector_j2<-cur_name
                  }else{
                    name_vector_j2<-c(name_vector_j2, cur_name)
                  }
              # print progress 
              print(paste("i=3, j=", j, " done"))
            } # end j loop 
            # name the levels 
            names(level_list)<-name_vector_j2
            # add to the tree outcome
            tree_output_list[[i]]<-level_list
            # print
              print("i=3 done")
          }
          
      } # end the for loop 
    names(tree_output_list)<-c("level1", "level2", "level3")
    # save it 
    setwd(file_folder)
    save(tree_output_list, file=paste0("branch", branch_num_og, "_sub2_x3_mod", model_type, ".Rda"))
   return(tree_output_list)
} # End the function 
```

Run the direct hoarder , 2 variables, 3 th model: 
```{r run subset 2 x3}
out_sub2_x3<-tree_func_sub2_x3(model_type=431, branch_num = 6)

```

## The x.3 models for subset 2 are too big when branching with 6 
As a solution, I'm just going to generate the levels separately. 
```{r make subset 2 x.3 models for seperate level branching }

# level 1 
    tree_func_sub2_x3_l1<-function(model_type, branch_num){
            # Log the original branch number
            branch_num_og<-branch_num
      # settings for first level 
      if((model_type==431)|(model_type==432)){
        # variable 1 = FR
        start_min_v1_th1<-0
        start_max_v1_th1<-4
        start_min_v1_th2<-0
        start_max_v1_th2<-4
        start_min_v1_th3<-0
        start_max_v1_th3<-4
        # variable 2 = FLR
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-0.6
        start_min_v2_th2<-(-0.6)
        start_max_v2_th2<-0.6
        start_min_v2_th3<-(-0.6)
        start_max_v2_th3<-0.6
      }else if(model_type==531|model_type==532){
        # variable 1 = SC
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v1_th2<-0
        start_max_v1_th2<-0.4
        start_min_v1_th3<-0
        start_max_v1_th3<-0.4
        # variable 2 = FR
        start_min_v2_th1<-0
        start_max_v2_th1<-4
        start_min_v2_th2<-0
        start_max_v2_th2<-4
        start_min_v2_th3<-0
        start_max_v2_th3<-4
      }else if(model_type==631|model_type==632){
        # variable 1 = SC
        start_min_v1_th1<-0
        start_max_v1_th1<-0.4
        start_min_v1_th2<-0
        start_max_v1_th2<-0.4
        start_min_v1_th3<-0
        start_max_v1_th3<-0.4
        # variable 2 = FLR
        start_min_v2_th1<-(-0.6)
        start_max_v2_th1<-0.6
        start_min_v2_th2<-(-0.6)
        start_max_v2_th2<-0.6
        start_min_v2_th3<-(-0.6)
        start_max_v2_th3<-0.6
      }else{print("something is wrong with the model_type setting")}

          # Create an empty list 
            tree_output_list<-list()
            stepsize_list<-list()
          # Run the function to branch for the first th 
              out_v1_th1<-branch_func(range_min = start_min_v1_th1, range_max = start_max_v1_th1, branch_num = branch_num)
              out_v2_th1<-branch_func(range_min= start_min_v2_th1, range_max = start_max_v2_th1, branch_num = branch_num)
              out_v1_th2<-branch_func(range_min = start_min_v1_th2, range_max = start_max_v1_th2, branch_num = branch_num)
              out_v2_th2<-branch_func(range_min= start_min_v2_th2, range_max = start_max_v2_th2, branch_num = branch_num)
              out_v1_th3<-branch_func(range_min = start_min_v1_th3, range_max = start_max_v1_th3, branch_num = branch_num)
              out_v2_th3<-branch_func(range_min= start_min_v2_th3, range_max = start_max_v2_th3, branch_num = branch_num)
          # Extract the stepsize 
              stepsize_list[[1]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                      out_v2_th1[branch_num+1], 
                                                      out_v1_th2[branch_num+1], 
                                                      out_v2_th2[branch_num+1], 
                                                      out_v1_th3[branch_num+1], 
                                                      out_v2_th3[branch_num+1]))
              colnames(stepsize_list[[1]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2", "step_v1_th3", "step_v2_th3")
            # Create a grid with all the possible combinations of th1 and th 2 
              grid<-expand.grid(out_v1_th1[1:branch_num], 
                                out_v2_th1[1:branch_num], 
                                out_v1_th2[1:branch_num], 
                                out_v2_th2[1:branch_num], 
                                out_v1_th3[1:branch_num], 
                                out_v2_th3[1:branch_num])
              colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2", "v1_th3", "v2_th3")
            # Subset this for cases 
                  grid<-grid%>%
                    filter(case_when( ((model_type=="431")|(model_type=="432"))~v1_th1>0 & v1_th2>0 & v1_th3>0, 
                                      ((model_type=="531")|(model_type=="532"))~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0 & v1_th3>0 & v2_th3>0,
                                      ((model_type=="631")|(model_type=="632"))~v1_th1>0 & v1_th2>0 & v1_th3>0))%>%
                    filter(v1_th1<v1_th2)%>%
                    filter(v2_th1<v2_th2)%>%
                    filter(v1_th2<v1_th3)%>%
                    filter(v2_th2<v2_th3)
            # Add the output to the list 
              tree_output_list[[1]]<-grid
              tree_output_list[[2]]<-stepsize_list
            # save it 
            setwd(file_folder)
            save(tree_output_list, file=paste0("branch", branch_num_og, "_sub2_x3_mod", model_type, "_l1.Rda"))
            rm(tree_output_list)
    } # end level 1 branching x.3 subset 2
            
```          

## Level 2 

```{r level 2 x.3 subset 2}        
# level 2
       tree_func_sub2_x3_l2<-function(model_type, branch_num){     
            branch_num_og<-branch_num
            # So for level 2
            # Set the branch number back to 4 if needed 
            branch_num<-4
            # Pull the original dataframe from level 1 
            setwd(file_folder)
            load(paste0("branch", branch_num_og, "_sub2_x3_mod", model_type, "_l1.Rda"))
            stepsize_list<-tree_output_list[[2]]
            
            # load the output from 1 
              for (j in 1:nrow(tree_output_list[[1]])){
                  if(j==1){
                    level_list<-list()
                    stepsize_list_j<-list()
                  }
                  # Calculate the new minimum for th1 
                  cur_min_v1_th1<-(tree_output_list[[1]][[1]][[j]]-(0.5*stepsize_list[[1]][[1]]))
                  cur_min_v2_th1<-(tree_output_list[[1]][[2]][[j]]-(0.5*stepsize_list[[1]][[2]]))
                  cur_min_v1_th2<-(tree_output_list[[1]][[3]][[j]]-(0.5*stepsize_list[[1]][[3]]))
                  cur_min_v2_th2<-(tree_output_list[[1]][[4]][[j]]-(0.5*stepsize_list[[1]][[4]]))
                  cur_min_v1_th3<-(tree_output_list[[1]][[5]][[j]]-(0.5*stepsize_list[[1]][[5]]))
                  cur_min_v2_th3<-(tree_output_list[[1]][[6]][[j]]-(0.5*stepsize_list[[1]][[6]]))
                  # calculate the new maximum 
                  cur_max_v1_th1<-(tree_output_list[[1]][[1]][[j]]+(0.5*stepsize_list[[1]][[1]]))
                  cur_max_v2_th1<-(tree_output_list[[1]][[2]][[j]]+(0.5*stepsize_list[[1]][[2]]))
                  cur_max_v1_th2<-(tree_output_list[[1]][[3]][[j]]+(0.5*stepsize_list[[1]][[3]]))
                  cur_max_v2_th2<-(tree_output_list[[1]][[4]][[j]]+(0.5*stepsize_list[[1]][[4]]))
                  cur_max_v1_th3<-(tree_output_list[[1]][[5]][[j]]+(0.5*stepsize_list[[1]][[5]]))
                  cur_max_v2_th3<-(tree_output_list[[1]][[6]][[j]]+(0.5*stepsize_list[[1]][[6]]))
                  # run the function 
                  out_v1_th1<-branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)
                  out_v2_th1<-branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)
                  out_v1_th2<-branch_func(range_min = cur_min_v1_th2, range_max = cur_max_v1_th2, branch_num = branch_num)
                  out_v2_th2<-branch_func(range_min = cur_min_v2_th2, range_max = cur_max_v2_th2, branch_num = branch_num)
                  out_v1_th3<-branch_func(range_min = cur_min_v1_th3, range_max = cur_max_v1_th3, branch_num = branch_num)
                  out_v2_th3<-branch_func(range_min = cur_min_v2_th3, range_max = cur_max_v2_th3, branch_num = branch_num)
                  
                  # Extract the stepsize - I know this overwrites, but it doesn't matter; should all be there same 
                  stepsize_list_j[[j]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                            out_v2_th1[branch_num+1], 
                                                            out_v1_th2[branch_num+1], 
                                                            out_v2_th2[branch_num+1], 
                                                            out_v1_th3[branch_num+1], 
                                                            out_v2_th3[branch_num+1] 
                                                            ))
                  colnames(stepsize_list_j[[j]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2", "step_v1_th3", "step_v2_th3")
                  # Create a grid with all the possible combinations of th1 and th 2 
                  grid<-expand.grid(out_v1_th1[1:branch_num], 
                                    out_v2_th1[1:branch_num], 
                                    out_v1_th2[1:branch_num], 
                                    out_v2_th2[1:branch_num], 
                                    out_v1_th3[1:branch_num], 
                                    out_v2_th3[1:branch_num])
                  # colnames 
                  colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2", "v1_th3", "v2_th3")
                  # Subset this for cases where th2 > th 1 
                          grid<-grid%>%
                    filter(case_when( ((model_type=="431")|(model_type=="432"))~v1_th1>0 & v1_th2>0 & v1_th3>0, 
                                      ((model_type=="531")|(model_type=="532"))~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0 & v1_th3>0 & v2_th3>0,
                                      ((model_type=="631")|(model_type=="632"))~v1_th1>0 & v1_th2>0 & v1_th3>0))%>%
                    filter(v1_th1<v1_th2)%>%
                    filter(v2_th1<v2_th2)%>%
                    filter(v1_th2<v1_th3)%>%
                    filter(v2_th2<v2_th3)
                  # Add the output to the list 
                  level_list[[j]]<-grid
                  #names(level_list[[j]])<-c("test5")
                  cur_name<-(paste(tree_output_list[[1]][[1]][[j]], "&", 
                                   tree_output_list[[1]][[2]][[j]], "&", 
                                   tree_output_list[[1]][[3]][[j]], "&", 
                                   tree_output_list[[1]][[4]][[j]], "&", 
                                   tree_output_list[[1]][[5]][[j]], "&", 
                                   tree_output_list[[1]][[6]][[j]]))
                  # attach to vector 
                  if(j==1){
                    name_vector_j<-cur_name
                  }else{
                    name_vector_j<-c(name_vector_j, cur_name)
                  }
              } # j loop end 
            
            # sort naming 
            names(level_list)<-name_vector_j
            # add to the tree outcome
            tree_output_list[[1]]<-level_list
            tree_output_list[[2]]<-stepsize_list_j
            # save it 
            setwd(file_folder)
            save(tree_output_list, file=paste0("branch", branch_num_og, "_sub2_x3_mod", model_type, "_l2.Rda"))
            rm(tree_output_list)
       } # end function branching x.3 subset 2 level 2
            
```

## Level 3 

```{r level 3 x.2 subest 2 function }
  # Level 3   
  tree_func_sub2_x3_l3<-function(model_type, branch_num){
            # For level 3 
            branch_num_og<-branch_num
            # Set the branch number back to 4 if needed 
            branch_num<-4
            # Pull the original dataframe from level 1 
            setwd(file_folder)
            load(paste0("branch", branch_num_og, "_sub2_x3_mod", model_type, "_l2.Rda"))
            stepsize_list<-tree_output_list[[2]]
            # print for keeping track: 
            print(paste("The number of js to do = ", length((tree_output_list[[1]]))))
            # Start looping 
            for (j in 1:length(tree_output_list[[1]])){
              
                  if(j==1){
                    level_list<-list()
                  }
                  # There are going to be 6 lists in here, we'll need to look at each of them 
                  # The default here would be 16 
                  for (k in 1:nrow(tree_output_list[[1]][[j]])){
                    
                      if(k==1){
                        list_new_th<-list()
                        stepsize_list_k<-list()
                      }
                      # Calculate the new minimum for th1 
                      cur_min_v1_th1<-(tree_output_list[[1]][[j]][[1]][[k]]-(0.5*stepsize_list[[j]][[1]]))
                      cur_min_v2_th1<-(tree_output_list[[1]][[j]][[2]][[k]]-(0.5*stepsize_list[[j]][[2]]))
                      cur_min_v1_th2<-(tree_output_list[[1]][[j]][[3]][[k]]-(0.5*stepsize_list[[j]][[3]]))
                      cur_min_v2_th2<-(tree_output_list[[1]][[j]][[4]][[k]]-(0.5*stepsize_list[[j]][[4]]))
                      cur_min_v1_th3<-(tree_output_list[[1]][[j]][[5]][[k]]-(0.5*stepsize_list[[j]][[5]]))
                      cur_min_v2_th3<-(tree_output_list[[1]][[j]][[6]][[k]]-(0.5*stepsize_list[[j]][[6]]))
                      # calculate the new maximum 
                      cur_max_v1_th1<-(tree_output_list[[1]][[j]][[1]][[k]]+(0.5*stepsize_list[[j]][[1]]))
                      cur_max_v2_th1<-(tree_output_list[[1]][[j]][[2]][[k]]+(0.5*stepsize_list[[j]][[2]]))
                      cur_max_v1_th2<-(tree_output_list[[1]][[j]][[3]][[k]]+(0.5*stepsize_list[[j]][[3]]))
                      cur_max_v2_th2<-(tree_output_list[[1]][[j]][[4]][[k]]+(0.5*stepsize_list[[j]][[4]]))
                      cur_max_v1_th3<-(tree_output_list[[1]][[j]][[5]][[k]]+(0.5*stepsize_list[[j]][[5]]))
                      cur_max_v2_th3<-(tree_output_list[[1]][[j]][[6]][[k]]+(0.5*stepsize_list[[j]][[6]]))
                      # run the function 
                      out_v1_th1<-t(as.data.frame(branch_func(range_min = cur_min_v1_th1, range_max = cur_max_v1_th1, branch_num = branch_num)))
                      out_v2_th1<-t(as.data.frame(branch_func(range_min = cur_min_v2_th1, range_max = cur_max_v2_th1, branch_num = branch_num)))
                      out_v1_th2<-t(as.data.frame(branch_func(range_min = cur_min_v1_th2, range_max = cur_max_v1_th2, branch_num = branch_num)))
                      out_v2_th2<-t(as.data.frame(branch_func(range_min = cur_min_v2_th2, range_max = cur_max_v2_th2, branch_num = branch_num)))
                      out_v1_th3<-t(as.data.frame(branch_func(range_min = cur_min_v1_th3, range_max = cur_max_v1_th3, branch_num = branch_num)))
                      out_v2_th3<-t(as.data.frame(branch_func(range_min = cur_min_v2_th3, range_max = cur_max_v2_th3, branch_num = branch_num)))
                      # Extract the stepsize (overwrites, but should all be teh same anyway )
                      stepsize_list_k[[k]]<-as.data.frame(cbind(out_v1_th1[branch_num+1], 
                                                                out_v2_th1[branch_num+1], 
                                                                out_v1_th2[branch_num+1], 
                                                                out_v2_th2[branch_num+1], 
                                                                out_v1_th3[branch_num+1], 
                                                                out_v2_th3[branch_num+1]))
                      colnames(stepsize_list_k[[k]])<-c("step_v1_th1", "step_v2_th1", "step_v1_th2", "step_v2_th2", "step_v1_th3", "step_v2_th3")
                      # Create a grid with all the possible combinations of th1 and th 2 
                      grid<-expand.grid(out_v1_th1[1:branch_num], 
                                        out_v2_th1[1:branch_num], 
                                        out_v1_th2[1:branch_num], 
                                        out_v2_th2[1:branch_num], 
                                        out_v1_th3[1:branch_num], 
                                        out_v2_th3[1:branch_num])
                      colnames(grid)<-c("v1_th1", "v2_th1", "v1_th2", "v2_th2", "v1_th3", "v2_th3")
                      # Subset this for cases where th2 > th 1 
                      grid<-grid%>%
                    filter(case_when( ((model_type=="431")|(model_type=="432"))~v1_th1>0 & v1_th2>0 & v1_th3>0, 
                                      ((model_type=="531")|(model_type=="532"))~v1_th1>0 & v2_th1>0 & v1_th2>0 & v2_th2>0 & v1_th3>0 & v2_th3>0,
                                      ((model_type=="631")|(model_type=="632"))~v1_th1>0 & v1_th2>0 & v1_th3>0))%>%
                    filter(v1_th1<v1_th2)%>%
                    filter(v2_th1<v2_th2)%>%
                    filter(v1_th2<v1_th3)%>%
                    filter(v2_th2<v2_th3)
                      # Add the output to the list 
                      list_new_th[[k]]<-grid
                      # do something about the  names 
                      cur_name<-(paste(tree_output_list[[1]][[j]][[1]][[k]], "&", 
                                       tree_output_list[[1]][[j]][[2]][[k]], "&", 
                                       tree_output_list[[1]][[j]][[3]][[k]], "&", 
                                       tree_output_list[[1]][[j]][[4]][[k]], "&", 
                                       tree_output_list[[1]][[j]][[5]][[k]], "&",
                                       tree_output_list[[1]][[j]][[6]][[k]]))
                  # attach to vector 
                  if(k==1){
                    name_vector_k<-cur_name
                  }else{
                    name_vector_k<-c(name_vector_k, cur_name)
                  }
                } # end of k loop 
                  # names 
                  names(list_new_th)<-name_vector_k

              # Add the list with thresholds to the level list
              level_list[[j]]<-list_new_th
              # # do something about the  names 
              # cur_name<-(paste(    tree_output_list[[1]][[1]][[1]][[j]], "&", 
              #                      tree_output_list[[1]][[1]][[2]][[j]], "&", 
              #                      tree_output_list[[1]][[1]][[3]][[j]], "&", 
              #                      tree_output_list[[1]][[1]][[4]][[j]], "&", 
              #                      tree_output_list[[1]][[1]][[5]][[j]], "&",
              #                      tree_output_list[[1]][[1]][[6]][[j]], "&"))
              # # attach to vector 
              # if(j==1){
              #       name_vector_j2<-cur_name
              #     }else{
              #       name_vector_j2<-c(name_vector_j2, cur_name)
              #     }
              # # print progress 
              print(paste("i=3, j=", j, " done"))
            } # end j loop 
            # name the levels 
            #names(level_list)<-name_vector_j2
            names(level_list)<-names(tree_output_list[[1]])
            # add to the tree outcome
            tree_output_list[[1]]<-level_list
            tree_output_list[[2]]<-stepsize_list
                        
            # save it 
            setwd(file_folder)
            save(tree_output_list, file=paste0("branch", branch_num_og, "_sub2_x3_mod", model_type, "_l3.Rda"))
            rm(tree_output_list)
   
          } # end of the x.3 subset 2 level 3 branching function 
          

```

run them 
```{r run the single level branches}
tree_func_sub2_x3_l1(631, 8)
tree_func_sub2_x3_l2(631, 8)
#tree_func_sub2_x3_l3(431, 6)

# 07/03/2024: level 3 is still too big to run. I should just run it only for hte relevant portion. 
```

I have now ran all the branches for all the models. Here is some code that can help me to select the correct dataframe for the next HPC run. I'm going to stop trying to do this all at once, it's taken too much time :( (02/02/24)


19/02/2024: Added the option for branching with 6 splits in the first level. The plan is to run this again for the 1st subset to see if this produces better results. 


